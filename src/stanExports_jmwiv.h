// Generated by rstantools.  Do not edit by hand.

/*
    rstanjmwiv is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    rstanjmwiv is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with rstanjmwiv.  If not, see <http://www.gnu.org/licenses/>.
*/
#ifndef MODELS_HPP
#define MODELS_HPP
#define STAN__SERVICES__COMMAND_HPP
#ifndef USE_STANC3
#define USE_STANC3
#endif
#include <rstan/rstaninc.hpp>
// Code generated by stanc v2.26.1-4-gd72b68b7-dirty
#include <stan/model/model_header.hpp>
namespace model_jmwiv_namespace {
inline void validate_positive_index(const char* var_name, const char* expr,
                                    int val) {
  if (val < 1) {
    std::stringstream msg;
    msg << "Found dimension size less than one in simplex declaration"
        << "; variable=" << var_name << "; dimension size expression=" << expr
        << "; expression value=" << val;
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}
inline void validate_unit_vector_index(const char* var_name, const char* expr,
                                       int val) {
  if (val <= 1) {
    std::stringstream msg;
    if (val == 1) {
      msg << "Found dimension size one in unit vector declaration."
          << " One-dimensional unit vector is discrete"
          << " but the target distribution must be continuous."
          << " variable=" << var_name << "; dimension size expression=" << expr;
    } else {
      msg << "Found dimension size less than one in unit vector declaration"
          << "; variable=" << var_name << "; dimension size expression=" << expr
          << "; expression value=" << val;
    }
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}
using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using std::pow;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using stan::model::cons_list;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::nil_index_list;
using namespace stan::math;
using stan::math::pow; 
stan::math::profile_map profiles__;
static int current_statement__= 0;
static const std::vector<string> locations_array__ = {" (found before start of program)",
                                                      " (in 'string', line 263, column 0 to column 16)",
                                                      " (in 'string', line 264, column 0 to column 19)",
                                                      " (in 'string', line 265, column 0 to column 16)",
                                                      " (in 'string', line 266, column 0 to column 19)",
                                                      " (in 'string', line 267, column 0 to column 29)",
                                                      " (in 'string', line 268, column 0 to column 35)",
                                                      " (in 'string', line 269, column 0 to column 29)",
                                                      " (in 'string', line 270, column 0 to column 35)",
                                                      " (in 'string', line 272, column 0 to column 26)",
                                                      " (in 'string', line 273, column 0 to column 24)",
                                                      " (in 'string', line 274, column 0 to column 51)",
                                                      " (in 'string', line 278, column 0 to column 21)",
                                                      " (in 'string', line 279, column 0 to column 21)",
                                                      " (in 'string', line 282, column 0 to column 34)",
                                                      " (in 'string', line 295, column 0 to column 27)",
                                                      " (in 'string', line 296, column 0 to column 33)",
                                                      " (in 'string', line 297, column 0 to column 27)",
                                                      " (in 'string', line 298, column 0 to column 33)",
                                                      " (in 'string', line 299, column 0 to column 19)",
                                                      " (in 'string', line 300, column 0 to column 19)",
                                                      " (in 'string', line 301, column 0 to column 25)",
                                                      " (in 'string', line 302, column 0 to column 22)",
                                                      " (in 'string', line 305, column 0 to column 62)",
                                                      " (in 'string', line 306, column 0 to column 62)",
                                                      " (in 'string', line 307, column 0 to column 74)",
                                                      " (in 'string', line 308, column 0 to column 74)",
                                                      " (in 'string', line 312, column 0 to column 50)",
                                                      " (in 'string', line 313, column 0 to column 50)",
                                                      " (in 'string', line 320, column 0 to column 71)",
                                                      " (in 'string', line 326, column 2 to column 59)",
                                                      " (in 'string', line 325, column 5 to line 326, column 59)",
                                                      " (in 'string', line 324, column 2 to column 31)",
                                                      " (in 'string', line 323, column 0 to line 326, column 59)",
                                                      " (in 'string', line 479, column 0 to column 20)",
                                                      " (in 'string', line 480, column 0 to column 20)",
                                                      " (in 'string', line 481, column 0 to column 23)",
                                                      " (in 'string', line 482, column 0 to column 23)",
                                                      " (in 'string', line 483, column 0 to column 17)",
                                                      " (in 'string', line 484, column 0 to column 30)",
                                                      " (in 'string', line 487, column 0 to column 64)",
                                                      " (in 'string', line 488, column 0 to column 64)",
                                                      " (in 'string', line 489, column 0 to column 76)",
                                                      " (in 'string', line 490, column 0 to column 76)",
                                                      " (in 'string', line 494, column 0 to column 48)",
                                                      " (in 'string', line 500, column 2 to line 501, column 20)",
                                                      " (in 'string', line 498, column 2 to column 31)",
                                                      " (in 'string', line 497, column 0 to line 501, column 20)",
                                                      " (in 'string', line 344, column 9 to column 15)",
                                                      " (in 'string', line 344, column 2 to column 26)",
                                                      " (in 'string', line 345, column 9 to column 15)",
                                                      " (in 'string', line 345, column 2 to column 29)",
                                                      " (in 'string', line 346, column 9 to column 15)",
                                                      " (in 'string', line 346, column 2 to column 26)",
                                                      " (in 'string', line 347, column 9 to column 15)",
                                                      " (in 'string', line 347, column 2 to column 29)",
                                                      " (in 'string', line 350, column 2 to column 84)",
                                                      " (in 'string', line 351, column 2 to column 100)",
                                                      " (in 'string', line 352, column 2 to column 105)",
                                                      " (in 'string', line 353, column 2 to column 125)",
                                                      " (in 'string', line 356, column 2 to column 57)",
                                                      " (in 'string', line 357, column 2 to column 57)",
                                                      " (in 'string', line 342, column 0 to line 358, column 1)",
                                                      " (in 'string', line 364, column 9 to column 18)",
                                                      " (in 'string', line 364, column 2 to column 28)",
                                                      " (in 'string', line 365, column 9 to column 18)",
                                                      " (in 'string', line 365, column 2 to column 32)",
                                                      " (in 'string', line 366, column 9 to column 18)",
                                                      " (in 'string', line 366, column 2 to column 30)",
                                                      " (in 'string', line 367, column 9 to column 16)",
                                                      " (in 'string', line 367, column 2 to column 33)",
                                                      " (in 'string', line 368, column 9 to column 26)",
                                                      " (in 'string', line 368, column 2 to column 43)",
                                                      " (in 'string', line 371, column 2 to column 26)",
                                                      " (in 'string', line 379, column 11 to column 23)",
                                                      " (in 'string', line 379, column 4 to column 36)",
                                                      " (in 'string', line 380, column 11 to column 23)",
                                                      " (in 'string', line 380, column 4 to column 36)",
                                                      " (in 'string', line 381, column 11 to column 23)",
                                                      " (in 'string', line 381, column 4 to column 39)",
                                                      " (in 'string', line 382, column 11 to column 23)",
                                                      " (in 'string', line 382, column 4 to column 39)",
                                                      " (in 'string', line 384, column 4 to column 91)",
                                                      " (in 'string', line 385, column 4 to column 107)",
                                                      " (in 'string', line 386, column 4 to column 112)",
                                                      " (in 'string', line 387, column 4 to column 132)",
                                                      " (in 'string', line 390, column 6 to column 41)",
                                                      " (in 'string', line 391, column 6 to column 41)",
                                                      " (in 'string', line 389, column 25 to line 392, column 5)",
                                                      " (in 'string', line 389, column 4 to line 392, column 5)",
                                                      " (in 'string', line 396, column 4 to column 119)",
                                                      " (in 'string', line 376, column 7 to line 398, column 3)",
                                                      " (in 'string', line 375, column 4 to column 145)",
                                                      " (in 'string', line 374, column 2 to line 398, column 3)",
                                                      " (in 'string', line 403, column 2 to column 47)",
                                                      " (in 'string', line 407, column 2 to column 36)",
                                                      " (in 'string', line 410, column 2 to column 44)",
                                                      " (in 'string', line 413, column 2 to column 54)",
                                                      " (in 'string', line 425, column 2 to column 73)",
                                                      " (in 'string', line 362, column 0 to line 426, column 1)",
                                                      " (in 'string', line 431, column 0 to line 432, column 67)",
                                                      " (in 'string', line 433, column 0 to line 434, column 67)",
                                                      " (in 'string', line 435, column 0 to line 436, column 73)",
                                                      " (in 'string', line 437, column 0 to line 438, column 73)",
                                                      " (in 'string', line 441, column 0 to column 42)",
                                                      " (in 'string', line 442, column 0 to column 45)",
                                                      " (in 'string', line 443, column 0 to column 42)",
                                                      " (in 'string', line 444, column 0 to column 45)",
                                                      " (in 'string', line 447, column 0 to column 39)",
                                                      " (in 'string', line 448, column 0 to column 39)",
                                                      " (in 'string', line 455, column 0 to column 45)",
                                                      " (in 'string', line 459, column 0 to column 62)",
                                                      " (in 'string', line 462, column 0 to column 49)",
                                                      " (in 'string', line 465, column 2 to column 72)",
                                                      " (in 'string', line 464, column 0 to line 465, column 72)",
                                                      " (in 'string', line 107, column 0 to column 23)",
                                                      " (in 'string', line 110, column 17 to column 18)",
                                                      " (in 'string', line 110, column 0 to column 20)",
                                                      " (in 'string', line 111, column 19 to column 20)",
                                                      " (in 'string', line 111, column 0 to column 22)",
                                                      " (in 'string', line 112, column 22 to column 23)",
                                                      " (in 'string', line 112, column 0 to column 25)",
                                                      " (in 'string', line 116, column 7 to column 13)",
                                                      " (in 'string', line 116, column 0 to column 18)",
                                                      " (in 'string', line 117, column 7 to column 13)",
                                                      " (in 'string', line 117, column 0 to column 18)",
                                                      " (in 'string', line 118, column 7 to column 13)",
                                                      " (in 'string', line 118, column 14 to column 22)",
                                                      " (in 'string', line 118, column 0 to column 31)",
                                                      " (in 'string', line 119, column 7 to column 13)",
                                                      " (in 'string', line 119, column 14 to column 22)",
                                                      " (in 'string', line 119, column 0 to column 31)",
                                                      " (in 'string', line 120, column 7 to column 13)",
                                                      " (in 'string', line 120, column 14 to column 25)",
                                                      " (in 'string', line 120, column 0 to column 37)",
                                                      " (in 'string', line 121, column 7 to column 13)",
                                                      " (in 'string', line 121, column 14 to column 25)",
                                                      " (in 'string', line 121, column 0 to column 37)",
                                                      " (in 'string', line 122, column 7 to column 15)",
                                                      " (in 'string', line 122, column 0 to column 27)",
                                                      " (in 'string', line 123, column 7 to column 15)",
                                                      " (in 'string', line 123, column 0 to column 27)",
                                                      " (in 'string', line 124, column 7 to column 18)",
                                                      " (in 'string', line 124, column 0 to column 33)",
                                                      " (in 'string', line 125, column 7 to column 18)",
                                                      " (in 'string', line 125, column 0 to column 33)",
                                                      " (in 'string', line 130, column 0 to column 17)",
                                                      " (in 'string', line 131, column 0 to column 17)",
                                                      " (in 'string', line 132, column 19 to column 20)",
                                                      " (in 'string', line 132, column 0 to column 22)",
                                                      " (in 'string', line 133, column 22 to column 23)",
                                                      " (in 'string', line 133, column 0 to column 25)",
                                                      " (in 'string', line 138, column 22 to column 30)",
                                                      " (in 'string', line 138, column 7 to column 13)",
                                                      " (in 'string', line 138, column 0 to column 32)",
                                                      " (in 'string', line 139, column 22 to column 30)",
                                                      " (in 'string', line 139, column 7 to column 13)",
                                                      " (in 'string', line 139, column 0 to column 32)",
                                                      " (in 'string', line 140, column 25 to column 36)",
                                                      " (in 'string', line 140, column 7 to column 13)",
                                                      " (in 'string', line 140, column 0 to column 38)",
                                                      " (in 'string', line 141, column 25 to column 36)",
                                                      " (in 'string', line 141, column 7 to column 13)",
                                                      " (in 'string', line 141, column 0 to column 38)",
                                                      " (in 'string', line 142, column 21 to column 27)",
                                                      " (in 'string', line 142, column 0 to column 29)",
                                                      " (in 'string', line 143, column 21 to column 27)",
                                                      " (in 'string', line 143, column 0 to column 29)",
                                                      " (in 'string', line 160, column 0 to column 17)",
                                                      " (in 'string', line 161, column 0 to column 18)",
                                                      " (in 'string', line 162, column 0 to column 21)",
                                                      " (in 'string', line 163, column 0 to column 20)",
                                                      " (in 'string', line 164, column 0 to column 31)",
                                                      " (in 'string', line 165, column 0 to column 23)",
                                                      " (in 'string', line 166, column 7 to column 16)",
                                                      " (in 'string', line 166, column 0 to column 26)",
                                                      " (in 'string', line 167, column 7 to column 16)",
                                                      " (in 'string', line 167, column 17 to column 20)",
                                                      " (in 'string', line 167, column 0 to column 27)",
                                                      " (in 'string', line 168, column 7 to column 10)",
                                                      " (in 'string', line 168, column 0 to column 19)",
                                                      " (in 'string', line 169, column 0 to column 24)",
                                                      " (in 'string', line 170, column 7 to column 16)",
                                                      " (in 'string', line 170, column 17 to column 27)",
                                                      " (in 'string', line 170, column 0 to column 39)",
                                                      " (in 'string', line 171, column 7 to column 24)",
                                                      " (in 'string', line 171, column 0 to column 31)",
                                                      " (in 'string', line 172, column 0 to column 16)",
                                                      " (in 'string', line 173, column 0 to column 16)",
                                                      " (in 'string', line 174, column 0 to column 17)",
                                                      " (in 'string', line 179, column 23 to column 24)",
                                                      " (in 'string', line 179, column 0 to column 26)",
                                                      " (in 'string', line 180, column 7 to column 19)",
                                                      " (in 'string', line 180, column 20 to column 28)",
                                                      " (in 'string', line 180, column 0 to column 38)",
                                                      " (in 'string', line 181, column 7 to column 19)",
                                                      " (in 'string', line 181, column 20 to column 28)",
                                                      " (in 'string', line 181, column 0 to column 38)",
                                                      " (in 'string', line 182, column 7 to column 19)",
                                                      " (in 'string', line 182, column 20 to column 31)",
                                                      " (in 'string', line 182, column 0 to column 44)",
                                                      " (in 'string', line 183, column 7 to column 19)",
                                                      " (in 'string', line 183, column 20 to column 31)",
                                                      " (in 'string', line 183, column 0 to column 44)",
                                                      " (in 'string', line 184, column 29 to column 37)",
                                                      " (in 'string', line 184, column 7 to column 19)",
                                                      " (in 'string', line 184, column 0 to column 39)",
                                                      " (in 'string', line 185, column 29 to column 37)",
                                                      " (in 'string', line 185, column 7 to column 19)",
                                                      " (in 'string', line 185, column 0 to column 39)",
                                                      " (in 'string', line 186, column 32 to column 43)",
                                                      " (in 'string', line 186, column 7 to column 19)",
                                                      " (in 'string', line 186, column 0 to column 45)",
                                                      " (in 'string', line 187, column 32 to column 43)",
                                                      " (in 'string', line 187, column 7 to column 19)",
                                                      " (in 'string', line 187, column 0 to column 45)",
                                                      " (in 'string', line 188, column 22 to column 34)",
                                                      " (in 'string', line 188, column 0 to column 36)",
                                                      " (in 'string', line 189, column 22 to column 34)",
                                                      " (in 'string', line 189, column 0 to column 36)",
                                                      " (in 'string', line 205, column 7 to column 15)",
                                                      " (in 'string', line 205, column 0 to column 37)",
                                                      " (in 'string', line 206, column 7 to column 15)",
                                                      " (in 'string', line 206, column 0 to column 37)",
                                                      " (in 'string', line 207, column 7 to column 18)",
                                                      " (in 'string', line 207, column 0 to column 40)",
                                                      " (in 'string', line 208, column 7 to column 18)",
                                                      " (in 'string', line 208, column 0 to column 40)",
                                                      " (in 'string', line 209, column 7 to column 10)",
                                                      " (in 'string', line 209, column 0 to column 34)",
                                                      " (in 'string', line 210, column 7 to column 10)",
                                                      " (in 'string', line 210, column 0 to column 34)",
                                                      " (in 'string', line 211, column 7 to column 8)",
                                                      " (in 'string', line 211, column 0 to column 50)",
                                                      " (in 'string', line 212, column 7 to column 8)",
                                                      " (in 'string', line 212, column 0 to column 53)",
                                                      " (in 'string', line 213, column 7 to column 17)",
                                                      " (in 'string', line 213, column 0 to column 42)",
                                                      " (in 'string', line 216, column 16 to column 24)",
                                                      " (in 'string', line 216, column 0 to column 43)",
                                                      " (in 'string', line 217, column 16 to column 24)",
                                                      " (in 'string', line 217, column 0 to column 43)",
                                                      " (in 'string', line 218, column 16 to column 27)",
                                                      " (in 'string', line 218, column 0 to column 49)",
                                                      " (in 'string', line 219, column 16 to column 27)",
                                                      " (in 'string', line 219, column 0 to column 49)",
                                                      " (in 'string', line 220, column 16 to column 19)",
                                                      " (in 'string', line 220, column 0 to column 38)",
                                                      " (in 'string', line 221, column 16 to column 19)",
                                                      " (in 'string', line 221, column 0 to column 38)",
                                                      " (in 'string', line 222, column 16 to column 17)",
                                                      " (in 'string', line 222, column 0 to column 54)",
                                                      " (in 'string', line 223, column 16 to column 17)",
                                                      " (in 'string', line 223, column 0 to column 57)",
                                                      " (in 'string', line 224, column 16 to column 26)",
                                                      " (in 'string', line 224, column 0 to column 50)",
                                                      " (in 'string', line 227, column 16 to column 19)",
                                                      " (in 'string', line 227, column 0 to column 35)",
                                                      " (in 'string', line 228, column 16 to column 19)",
                                                      " (in 'string', line 228, column 0 to column 32)",
                                                      " (in 'string', line 229, column 0 to column 37)",
                                                      " (in 'string', line 242, column 20 to column 23)",
                                                      " (in 'string', line 242, column 2 to column 74)",
                                                      " (in 'string', line 248, column 16 to column 36)",
                                                      " (in 'string', line 248, column 2 to column 38)",
                                                      " (in 'string', line 250, column 4 to column 39)",
                                                      " (in 'string', line 249, column 2 to line 250, column 39)",
                                                      " (in 'string', line 267, column 7 to column 15)",
                                                      " (in 'string', line 268, column 7 to column 18)",
                                                      " (in 'string', line 269, column 7 to column 15)",
                                                      " (in 'string', line 270, column 7 to column 18)",
                                                      " (in 'string', line 272, column 16 to column 19)",
                                                      " (in 'string', line 273, column 7 to column 10)",
                                                      " (in 'string', line 273, column 11 to column 14)",
                                                      " (in 'string', line 274, column 21 to column 38)",
                                                      " (in 'string', line 278, column 7 to column 10)",
                                                      " (in 'string', line 279, column 7 to column 10)",
                                                      " (in 'string', line 282, column 7 to column 17)",
                                                      " (in 'string', line 295, column 7 to column 15)",
                                                      " (in 'string', line 296, column 7 to column 18)",
                                                      " (in 'string', line 297, column 7 to column 15)",
                                                      " (in 'string', line 298, column 7 to column 18)",
                                                      " (in 'string', line 299, column 7 to column 10)",
                                                      " (in 'string', line 300, column 7 to column 10)",
                                                      " (in 'string', line 301, column 7 to column 17)",
                                                      " (in 'string', line 302, column 7 to column 10)",
                                                      " (in 'string', line 302, column 11 to column 14)",
                                                      " (in 'string', line 484, column 7 to column 22)",
                                                      " (in 'string', line 34, column 2 to column 18)",
                                                      " (in 'string', line 35, column 2 to column 21)",
                                                      " (in 'string', line 36, column 2 to column 18)",
                                                      " (in 'string', line 37, column 9 to column 10)",
                                                      " (in 'string', line 37, column 2 to column 16)",
                                                      " (in 'string', line 40, column 7 to column 40)",
                                                      " (in 'string', line 39, column 13 to column 36)",
                                                      " (in 'string', line 39, column 2 to line 40, column 40)",
                                                      " (in 'string', line 44, column 2 to column 56)",
                                                      " (in 'string', line 43, column 2 to line 44, column 56)",
                                                      " (in 'string', line 42, column 2 to line 44, column 56)",
                                                      " (in 'string', line 46, column 2 to column 13)",
                                                      " (in 'string', line 33, column 37 to line 47, column 1)",
                                                      " (in 'string', line 56, column 14 to column 34)",
                                                      " (in 'string', line 56, column 2 to column 36)",
                                                      " (in 'string', line 57, column 2 to column 15)",
                                                      " (in 'string', line 60, column 6 to column 40)",
                                                      " (in 'string', line 61, column 6 to column 22)",
                                                      " (in 'string', line 59, column 21 to line 62, column 5)",
                                                      " (in 'string', line 59, column 4 to line 62, column 5)",
                                                      " (in 'string', line 58, column 19 to line 63, column 3)",
                                                      " (in 'string', line 58, column 2 to line 63, column 3)",
                                                      " (in 'string', line 64, column 2 to column 17)",
                                                      " (in 'string', line 55, column 33 to line 65, column 1)",
                                                      " (in 'string', line 76, column 2 to column 22)",
                                                      " (in 'string', line 77, column 9 to column 13)",
                                                      " (in 'string', line 77, column 15 to column 17)",
                                                      " (in 'string', line 77, column 2 to column 26)",
                                                      " (in 'string', line 80, column 4 to column 34)",
                                                      " (in 'string', line 79, column 20 to line 81, column 3)",
                                                      " (in 'string', line 79, column 2 to line 81, column 3)",
                                                      " (in 'string', line 83, column 2 to column 16)",
                                                      " (in 'string', line 75, column 58 to line 84, column 1)"};
template <typename T0__, typename T1__, typename T3__, typename T4__,
typename T5__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>, T1__, T3__,
stan::value_type_t<T4__>,
stan::value_type_t<T5__>>, -1, 1>
evaluate_eta(const T0__& X_arg__,
             const std::vector<Eigen::Matrix<T1__, -1, 1>>& Z,
             const std::vector<int>& Z_id, const T3__& gamma,
             const T4__& beta_arg__, const T5__& bMat_arg__,
             const int& shift, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T0__>,
          T1__,
          T3__,
          stan::value_type_t<T4__>,
          stan::value_type_t<T5__>>;
  const auto& X = to_ref(X_arg__);
  const auto& beta = to_ref(beta_arg__);
  const auto& bMat = to_ref(bMat_arg__);
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    int N;
    N = std::numeric_limits<int>::min();
    
    current_statement__ = 288;
    N = rows(X);
    int K;
    K = std::numeric_limits<int>::min();
    
    current_statement__ = 289;
    K = rows(beta);
    int p;
    p = std::numeric_limits<int>::min();
    
    current_statement__ = 290;
    p = stan::math::size(Z);
    current_statement__ = 291;
    validate_non_negative_index("eta", "N", N);
    Eigen::Matrix<local_scalar_t__, -1, 1> eta;
    eta = Eigen::Matrix<local_scalar_t__, -1, 1>(N);
    stan::math::fill(eta, DUMMY_VAR__);
    
    current_statement__ = 295;
    if (logical_gt(K, 0)) {
      current_statement__ = 294;
      assign(eta, nil_index_list(), add(multiply(X, beta), gamma),
        "assigning variable eta");
    } else {
      current_statement__ = 293;
      assign(eta, nil_index_list(), add(rep_vector(0.0, N), gamma),
        "assigning variable eta");
    }
    current_statement__ = 298;
    for (int k = 1; k <= p; ++k) {
      current_statement__ = 297;
      for (int n = 1; n <= N; ++n) {
        current_statement__ = 296;
        assign(eta, cons_list(index_uni(n), nil_index_list()),
          (eta[(n - 1)] +
            (rvalue(bMat,
               cons_list(index_uni(Z_id[(n - 1)]),
                 cons_list(index_uni((k + shift)), nil_index_list())),
               "bMat") * Z[(k - 1)][(n - 1)])), "assigning variable eta");}}
    current_statement__ = 299;
    return eta;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct evaluate_eta_functor__ {
template <typename T0__, typename T1__, typename T3__, typename T4__,
typename T5__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>, T1__, T3__,
stan::value_type_t<T4__>,
stan::value_type_t<T5__>>, -1, 1>
operator()(const T0__& X, const std::vector<Eigen::Matrix<T1__, -1, 1>>& Z,
           const std::vector<int>& Z_id, const T3__& gamma, const T4__& beta,
           const T5__& bMat, const int& shift, std::ostream* pstream__)  const 
{
return evaluate_eta(X, Z, Z_id, gamma, beta, bMat, shift, pstream__);
}
};
std::vector<int>
lower_tri_indices(const int& dim, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 301;
    validate_non_negative_index("indices", "dim + choose(dim, 2)",
                                (dim + choose(dim, 2)));
    std::vector<int> indices;
    indices = std::vector<int>((dim + choose(dim, 2)), std::numeric_limits<int>::min());
    
    int mark;
    mark = std::numeric_limits<int>::min();
    
    current_statement__ = 303;
    mark = 1;
    current_statement__ = 309;
    for (int r = 1; r <= dim; ++r) {
      current_statement__ = 307;
      for (int c = r; c <= dim; ++c) {
        current_statement__ = 304;
        assign(indices, cons_list(index_uni(mark), nil_index_list()),
          (((r - 1) * dim) + c), "assigning variable indices");
        current_statement__ = 305;
        mark = (mark + 1);}}
    current_statement__ = 310;
    return indices;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct lower_tri_indices_functor__ {
std::vector<int>
operator()(const int& dim, std::ostream* pstream__)  const 
{
return lower_tri_indices(dim, pstream__);
}
};
template <typename T0__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>>, -1, -1>
evaluate_bMat_q(const T0__& bMat_arg__, const std::vector<int>& Z_id,
                const int& nrow, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T0__>>;
  const auto& bMat = to_ref(bMat_arg__);
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    int bK;
    bK = std::numeric_limits<int>::min();
    
    current_statement__ = 312;
    bK = cols(bMat);
    current_statement__ = 313;
    validate_non_negative_index("bMat_q", "nrow", nrow);
    current_statement__ = 314;
    validate_non_negative_index("bMat_q", "bK", bK);
    Eigen::Matrix<local_scalar_t__, -1, -1> bMat_q;
    bMat_q = Eigen::Matrix<local_scalar_t__, -1, -1>(nrow, bK);
    stan::math::fill(bMat_q, DUMMY_VAR__);
    
    current_statement__ = 318;
    for (int i = 1; i <= nrow; ++i) {
      current_statement__ = 316;
      assign(bMat_q,
        cons_list(index_uni(i), cons_list(index_omni(), nil_index_list())),
        rvalue(bMat,
          cons_list(index_uni(Z_id[(i - 1)]),
            cons_list(index_omni(), nil_index_list())), "bMat"),
        "assigning variable bMat_q");}
    current_statement__ = 319;
    return bMat_q;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct evaluate_bMat_q_functor__ {
template <typename T0__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>>, -1, -1>
operator()(const T0__& bMat, const std::vector<int>& Z_id, const int& nrow,
           std::ostream* pstream__)  const 
{
return evaluate_bMat_q(bMat, Z_id, nrow, pstream__);
}
};
#include <stan_meta_header.hpp>
class model_jmwiv final : public model_base_crtp<model_jmwiv> {
private:
  int M;
  std::vector<int> y_N;
  std::vector<int> ymu_K;
  std::vector<int> ysigma_K;
  Eigen::Matrix<double, -1, 1> y1;
  Eigen::Matrix<double, -1, 1> y2;
  Eigen::Matrix<double, -1, -1> y1mu_X;
  Eigen::Matrix<double, -1, -1> y2mu_X;
  Eigen::Matrix<double, -1, -1> y1sigma_X;
  Eigen::Matrix<double, -1, -1> y2sigma_X;
  Eigen::Matrix<double, -1, 1> y1mu_Xbar;
  Eigen::Matrix<double, -1, 1> y2mu_Xbar;
  Eigen::Matrix<double, -1, 1> y1sigma_Xbar;
  Eigen::Matrix<double, -1, 1> y2sigma_Xbar;
  int b_N;
  int b_K;
  std::vector<int> bmu_K;
  std::vector<int> bsigma_K;
  std::vector<Eigen::Matrix<double, -1, 1>> y1mu_Z;
  std::vector<Eigen::Matrix<double, -1, 1>> y2mu_Z;
  std::vector<Eigen::Matrix<double, -1, 1>> y1sigma_Z;
  std::vector<Eigen::Matrix<double, -1, 1>> y2sigma_Z;
  std::vector<int> y1_Z_id;
  std::vector<int> y2_Z_id;
  int e_K;
  int Npat;
  int Nevents;
  int qnodes;
  int Npat_times_qnodes;
  int nrow_e_Xq;
  Eigen::Matrix<double, -1, 1> e_times;
  Eigen::Matrix<double, -1, -1> e_Xq;
  Eigen::Matrix<double, -1, 1> e_Xbar;
  int basehaz_df;
  Eigen::Matrix<double, -1, -1> basehaz_X;
  Eigen::Matrix<double, -1, 1> qwts;
  double norm_const;
  double assoc_code;
  int a_K;
  std::vector<int> nrow_y_Xq;
  Eigen::Matrix<double, -1, -1> y1mu_Xq;
  Eigen::Matrix<double, -1, -1> y2mu_Xq;
  Eigen::Matrix<double, -1, -1> y1sigma_Xq;
  Eigen::Matrix<double, -1, -1> y2sigma_Xq;
  std::vector<Eigen::Matrix<double, -1, 1>> y1mu_Zq;
  std::vector<Eigen::Matrix<double, -1, 1>> y2mu_Zq;
  std::vector<Eigen::Matrix<double, -1, 1>> y1sigma_Zq;
  std::vector<Eigen::Matrix<double, -1, 1>> y2sigma_Zq;
  std::vector<int> y1_Zq_id;
  std::vector<int> y2_Zq_id;
  Eigen::Matrix<double, -1, 1> y1mu_prior_mean;
  Eigen::Matrix<double, -1, 1> y2mu_prior_mean;
  Eigen::Matrix<double, -1, 1> y1sigma_prior_mean;
  Eigen::Matrix<double, -1, 1> y2sigma_prior_mean;
  Eigen::Matrix<double, -1, 1> e_prior_mean;
  Eigen::Matrix<double, -1, 1> a_prior_mean;
  Eigen::Matrix<double, -1, 1> ymu_prior_mean_for_intercept;
  Eigen::Matrix<double, -1, 1> ysigma_prior_mean_for_intercept;
  Eigen::Matrix<double, -1, 1> e_prior_mean_for_aux;
  Eigen::Matrix<double, -1, 1> y1mu_prior_scale;
  Eigen::Matrix<double, -1, 1> y2mu_prior_scale;
  Eigen::Matrix<double, -1, 1> y1sigma_prior_scale;
  Eigen::Matrix<double, -1, 1> y2sigma_prior_scale;
  Eigen::Matrix<double, -1, 1> e_prior_scale;
  Eigen::Matrix<double, -1, 1> a_prior_scale;
  Eigen::Matrix<double, -1, 1> ymu_prior_scale_for_intercept;
  Eigen::Matrix<double, -1, 1> ysigma_prior_scale_for_intercept;
  Eigen::Matrix<double, -1, 1> e_prior_scale_for_aux;
  Eigen::Matrix<double, -1, 1> b_prior_scale;
  Eigen::Matrix<double, -1, 1> b_prior_df;
  double b_prior_regularization;
  std::vector<int> b_KM;
  std::vector<int> b_cov_idx;
  int y1mu_z_beta_1dim__;
  int y1sigma_z_beta_1dim__;
  int y2mu_z_beta_1dim__;
  int y2sigma_z_beta_1dim__;
  int b_cholesky_1dim__;
  int b_cholesky_2dim__;
  int y1mu_beta_1dim__;
  int y1sigma_beta_1dim__;
  int y2mu_beta_1dim__;
  int y2sigma_beta_1dim__;
  int b_cov_1dim__;
 
public:
  ~model_jmwiv() { }
  
  inline std::string model_name() const final { return "model_jmwiv"; }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = stanc3 v2.26.1-4-gd72b68b7-dirty", "stancflags = "};
  }
  
  
  model_jmwiv(stan::io::var_context& context__,
              unsigned int random_seed__ = 0,
              std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static const char* function__ = "model_jmwiv_namespace::model_jmwiv";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      current_statement__ = 115;
      context__.validate_dims("data initialization","M","int",
          context__.to_vec());
      M = std::numeric_limits<int>::min();
      
      current_statement__ = 115;
      M = context__.vals_i("M")[(1 - 1)];
      current_statement__ = 115;
      current_statement__ = 115;
      check_greater_or_equal(function__, "M", M, 1);
      current_statement__ = 115;
      current_statement__ = 115;
      check_less_or_equal(function__, "M", M, 2);
      current_statement__ = 116;
      validate_non_negative_index("y_N", "M", M);
      current_statement__ = 117;
      context__.validate_dims("data initialization","y_N","int",
          context__.to_vec(M));
      y_N = std::vector<int>(M, std::numeric_limits<int>::min());
      
      current_statement__ = 117;
      assign(y_N, nil_index_list(), context__.vals_i("y_N"),
        "assigning variable y_N");
      current_statement__ = 117;
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        current_statement__ = 117;
        current_statement__ = 117;
        check_greater_or_equal(function__, "y_N[sym1__]", y_N[(sym1__ - 1)],
                               0);}
      current_statement__ = 118;
      validate_non_negative_index("ymu_K", "M", M);
      current_statement__ = 119;
      context__.validate_dims("data initialization","ymu_K","int",
          context__.to_vec(M));
      ymu_K = std::vector<int>(M, std::numeric_limits<int>::min());
      
      current_statement__ = 119;
      assign(ymu_K, nil_index_list(), context__.vals_i("ymu_K"),
        "assigning variable ymu_K");
      current_statement__ = 119;
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        current_statement__ = 119;
        current_statement__ = 119;
        check_greater_or_equal(function__, "ymu_K[sym1__]",
                               ymu_K[(sym1__ - 1)], 0);}
      current_statement__ = 120;
      validate_non_negative_index("ysigma_K", "M", M);
      current_statement__ = 121;
      context__.validate_dims("data initialization","ysigma_K","int",
          context__.to_vec(M));
      ysigma_K = std::vector<int>(M, std::numeric_limits<int>::min());
      
      current_statement__ = 121;
      assign(ysigma_K, nil_index_list(), context__.vals_i("ysigma_K"),
        "assigning variable ysigma_K");
      current_statement__ = 121;
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        current_statement__ = 121;
        current_statement__ = 121;
        check_greater_or_equal(function__, "ysigma_K[sym1__]",
                               ysigma_K[(sym1__ - 1)], 0);}
      current_statement__ = 122;
      validate_non_negative_index("y1", "y_N[1]", y_N[(1 - 1)]);
      current_statement__ = 123;
      context__.validate_dims("data initialization","y1","double",
          context__.to_vec(y_N[(1 - 1)]));
      y1 = Eigen::Matrix<double, -1, 1>(y_N[(1 - 1)]);
      stan::math::fill(y1, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> y1_flat__;
        current_statement__ = 123;
        assign(y1_flat__, nil_index_list(), context__.vals_r("y1"),
          "assigning variable y1_flat__");
        current_statement__ = 123;
        pos__ = 1;
        current_statement__ = 123;
        for (int sym1__ = 1; sym1__ <= y_N[(1 - 1)]; ++sym1__) {
          current_statement__ = 123;
          assign(y1, cons_list(index_uni(sym1__), nil_index_list()),
            y1_flat__[(pos__ - 1)], "assigning variable y1");
          current_statement__ = 123;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 124;
      validate_non_negative_index("y2", "y_N[2]", y_N[(2 - 1)]);
      current_statement__ = 125;
      context__.validate_dims("data initialization","y2","double",
          context__.to_vec(y_N[(2 - 1)]));
      y2 = Eigen::Matrix<double, -1, 1>(y_N[(2 - 1)]);
      stan::math::fill(y2, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> y2_flat__;
        current_statement__ = 125;
        assign(y2_flat__, nil_index_list(), context__.vals_r("y2"),
          "assigning variable y2_flat__");
        current_statement__ = 125;
        pos__ = 1;
        current_statement__ = 125;
        for (int sym1__ = 1; sym1__ <= y_N[(2 - 1)]; ++sym1__) {
          current_statement__ = 125;
          assign(y2, cons_list(index_uni(sym1__), nil_index_list()),
            y2_flat__[(pos__ - 1)], "assigning variable y2");
          current_statement__ = 125;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 126;
      validate_non_negative_index("y1mu_X", "y_N[1]", y_N[(1 - 1)]);
      current_statement__ = 127;
      validate_non_negative_index("y1mu_X", "ymu_K[1]", ymu_K[(1 - 1)]);
      current_statement__ = 128;
      context__.validate_dims("data initialization","y1mu_X","double",
          context__.to_vec(y_N[(1 - 1)], ymu_K[(1 - 1)]));
      y1mu_X = Eigen::Matrix<double, -1, -1>(y_N[(1 - 1)], ymu_K[(1 - 1)]);
      stan::math::fill(y1mu_X, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> y1mu_X_flat__;
        current_statement__ = 128;
        assign(y1mu_X_flat__, nil_index_list(), context__.vals_r("y1mu_X"),
          "assigning variable y1mu_X_flat__");
        current_statement__ = 128;
        pos__ = 1;
        current_statement__ = 128;
        for (int sym1__ = 1; sym1__ <= ymu_K[(1 - 1)]; ++sym1__) {
          current_statement__ = 128;
          for (int sym2__ = 1; sym2__ <= y_N[(1 - 1)]; ++sym2__) {
            current_statement__ = 128;
            assign(y1mu_X,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              y1mu_X_flat__[(pos__ - 1)], "assigning variable y1mu_X");
            current_statement__ = 128;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 129;
      validate_non_negative_index("y2mu_X", "y_N[2]", y_N[(2 - 1)]);
      current_statement__ = 130;
      validate_non_negative_index("y2mu_X", "ymu_K[2]", ymu_K[(2 - 1)]);
      current_statement__ = 131;
      context__.validate_dims("data initialization","y2mu_X","double",
          context__.to_vec(y_N[(2 - 1)], ymu_K[(2 - 1)]));
      y2mu_X = Eigen::Matrix<double, -1, -1>(y_N[(2 - 1)], ymu_K[(2 - 1)]);
      stan::math::fill(y2mu_X, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> y2mu_X_flat__;
        current_statement__ = 131;
        assign(y2mu_X_flat__, nil_index_list(), context__.vals_r("y2mu_X"),
          "assigning variable y2mu_X_flat__");
        current_statement__ = 131;
        pos__ = 1;
        current_statement__ = 131;
        for (int sym1__ = 1; sym1__ <= ymu_K[(2 - 1)]; ++sym1__) {
          current_statement__ = 131;
          for (int sym2__ = 1; sym2__ <= y_N[(2 - 1)]; ++sym2__) {
            current_statement__ = 131;
            assign(y2mu_X,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              y2mu_X_flat__[(pos__ - 1)], "assigning variable y2mu_X");
            current_statement__ = 131;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 132;
      validate_non_negative_index("y1sigma_X", "y_N[1]", y_N[(1 - 1)]);
      current_statement__ = 133;
      validate_non_negative_index("y1sigma_X", "ysigma_K[1]",
                                  ysigma_K[(1 - 1)]);
      current_statement__ = 134;
      context__.validate_dims("data initialization","y1sigma_X","double",
          context__.to_vec(y_N[(1 - 1)], ysigma_K[(1 - 1)]));
      y1sigma_X = Eigen::Matrix<double, -1, -1>(y_N[(1 - 1)], ysigma_K[
        (1 - 1)]);
      stan::math::fill(y1sigma_X, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> y1sigma_X_flat__;
        current_statement__ = 134;
        assign(y1sigma_X_flat__, nil_index_list(),
          context__.vals_r("y1sigma_X"),
          "assigning variable y1sigma_X_flat__");
        current_statement__ = 134;
        pos__ = 1;
        current_statement__ = 134;
        for (int sym1__ = 1; sym1__ <= ysigma_K[(1 - 1)]; ++sym1__) {
          current_statement__ = 134;
          for (int sym2__ = 1; sym2__ <= y_N[(1 - 1)]; ++sym2__) {
            current_statement__ = 134;
            assign(y1sigma_X,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              y1sigma_X_flat__[(pos__ - 1)], "assigning variable y1sigma_X");
            current_statement__ = 134;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 135;
      validate_non_negative_index("y2sigma_X", "y_N[2]", y_N[(2 - 1)]);
      current_statement__ = 136;
      validate_non_negative_index("y2sigma_X", "ysigma_K[2]",
                                  ysigma_K[(2 - 1)]);
      current_statement__ = 137;
      context__.validate_dims("data initialization","y2sigma_X","double",
          context__.to_vec(y_N[(2 - 1)], ysigma_K[(2 - 1)]));
      y2sigma_X = Eigen::Matrix<double, -1, -1>(y_N[(2 - 1)], ysigma_K[
        (2 - 1)]);
      stan::math::fill(y2sigma_X, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> y2sigma_X_flat__;
        current_statement__ = 137;
        assign(y2sigma_X_flat__, nil_index_list(),
          context__.vals_r("y2sigma_X"),
          "assigning variable y2sigma_X_flat__");
        current_statement__ = 137;
        pos__ = 1;
        current_statement__ = 137;
        for (int sym1__ = 1; sym1__ <= ysigma_K[(2 - 1)]; ++sym1__) {
          current_statement__ = 137;
          for (int sym2__ = 1; sym2__ <= y_N[(2 - 1)]; ++sym2__) {
            current_statement__ = 137;
            assign(y2sigma_X,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              y2sigma_X_flat__[(pos__ - 1)], "assigning variable y2sigma_X");
            current_statement__ = 137;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 138;
      validate_non_negative_index("y1mu_Xbar", "ymu_K[1]", ymu_K[(1 - 1)]);
      current_statement__ = 139;
      context__.validate_dims("data initialization","y1mu_Xbar","double",
          context__.to_vec(ymu_K[(1 - 1)]));
      y1mu_Xbar = Eigen::Matrix<double, -1, 1>(ymu_K[(1 - 1)]);
      stan::math::fill(y1mu_Xbar, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> y1mu_Xbar_flat__;
        current_statement__ = 139;
        assign(y1mu_Xbar_flat__, nil_index_list(),
          context__.vals_r("y1mu_Xbar"),
          "assigning variable y1mu_Xbar_flat__");
        current_statement__ = 139;
        pos__ = 1;
        current_statement__ = 139;
        for (int sym1__ = 1; sym1__ <= ymu_K[(1 - 1)]; ++sym1__) {
          current_statement__ = 139;
          assign(y1mu_Xbar, cons_list(index_uni(sym1__), nil_index_list()),
            y1mu_Xbar_flat__[(pos__ - 1)], "assigning variable y1mu_Xbar");
          current_statement__ = 139;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 140;
      validate_non_negative_index("y2mu_Xbar", "ymu_K[2]", ymu_K[(2 - 1)]);
      current_statement__ = 141;
      context__.validate_dims("data initialization","y2mu_Xbar","double",
          context__.to_vec(ymu_K[(2 - 1)]));
      y2mu_Xbar = Eigen::Matrix<double, -1, 1>(ymu_K[(2 - 1)]);
      stan::math::fill(y2mu_Xbar, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> y2mu_Xbar_flat__;
        current_statement__ = 141;
        assign(y2mu_Xbar_flat__, nil_index_list(),
          context__.vals_r("y2mu_Xbar"),
          "assigning variable y2mu_Xbar_flat__");
        current_statement__ = 141;
        pos__ = 1;
        current_statement__ = 141;
        for (int sym1__ = 1; sym1__ <= ymu_K[(2 - 1)]; ++sym1__) {
          current_statement__ = 141;
          assign(y2mu_Xbar, cons_list(index_uni(sym1__), nil_index_list()),
            y2mu_Xbar_flat__[(pos__ - 1)], "assigning variable y2mu_Xbar");
          current_statement__ = 141;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 142;
      validate_non_negative_index("y1sigma_Xbar", "ysigma_K[1]",
                                  ysigma_K[(1 - 1)]);
      current_statement__ = 143;
      context__.validate_dims("data initialization","y1sigma_Xbar","double",
          context__.to_vec(ysigma_K[(1 - 1)]));
      y1sigma_Xbar = Eigen::Matrix<double, -1, 1>(ysigma_K[(1 - 1)]);
      stan::math::fill(y1sigma_Xbar, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> y1sigma_Xbar_flat__;
        current_statement__ = 143;
        assign(y1sigma_Xbar_flat__, nil_index_list(),
          context__.vals_r("y1sigma_Xbar"),
          "assigning variable y1sigma_Xbar_flat__");
        current_statement__ = 143;
        pos__ = 1;
        current_statement__ = 143;
        for (int sym1__ = 1; sym1__ <= ysigma_K[(1 - 1)]; ++sym1__) {
          current_statement__ = 143;
          assign(y1sigma_Xbar,
            cons_list(index_uni(sym1__), nil_index_list()),
            y1sigma_Xbar_flat__[(pos__ - 1)],
            "assigning variable y1sigma_Xbar");
          current_statement__ = 143;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 144;
      validate_non_negative_index("y2sigma_Xbar", "ysigma_K[2]",
                                  ysigma_K[(2 - 1)]);
      current_statement__ = 145;
      context__.validate_dims("data initialization","y2sigma_Xbar","double",
          context__.to_vec(ysigma_K[(2 - 1)]));
      y2sigma_Xbar = Eigen::Matrix<double, -1, 1>(ysigma_K[(2 - 1)]);
      stan::math::fill(y2sigma_Xbar, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> y2sigma_Xbar_flat__;
        current_statement__ = 145;
        assign(y2sigma_Xbar_flat__, nil_index_list(),
          context__.vals_r("y2sigma_Xbar"),
          "assigning variable y2sigma_Xbar_flat__");
        current_statement__ = 145;
        pos__ = 1;
        current_statement__ = 145;
        for (int sym1__ = 1; sym1__ <= ysigma_K[(2 - 1)]; ++sym1__) {
          current_statement__ = 145;
          assign(y2sigma_Xbar,
            cons_list(index_uni(sym1__), nil_index_list()),
            y2sigma_Xbar_flat__[(pos__ - 1)],
            "assigning variable y2sigma_Xbar");
          current_statement__ = 145;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 146;
      context__.validate_dims("data initialization","b_N","int",
          context__.to_vec());
      b_N = std::numeric_limits<int>::min();
      
      current_statement__ = 146;
      b_N = context__.vals_i("b_N")[(1 - 1)];
      current_statement__ = 146;
      current_statement__ = 146;
      check_greater_or_equal(function__, "b_N", b_N, 0);
      current_statement__ = 147;
      context__.validate_dims("data initialization","b_K","int",
          context__.to_vec());
      b_K = std::numeric_limits<int>::min();
      
      current_statement__ = 147;
      b_K = context__.vals_i("b_K")[(1 - 1)];
      current_statement__ = 147;
      current_statement__ = 147;
      check_greater_or_equal(function__, "b_K", b_K, 0);
      current_statement__ = 148;
      validate_non_negative_index("bmu_K", "M", M);
      current_statement__ = 149;
      context__.validate_dims("data initialization","bmu_K","int",
          context__.to_vec(M));
      bmu_K = std::vector<int>(M, std::numeric_limits<int>::min());
      
      current_statement__ = 149;
      assign(bmu_K, nil_index_list(), context__.vals_i("bmu_K"),
        "assigning variable bmu_K");
      current_statement__ = 149;
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        current_statement__ = 149;
        current_statement__ = 149;
        check_greater_or_equal(function__, "bmu_K[sym1__]",
                               bmu_K[(sym1__ - 1)], 0);}
      current_statement__ = 150;
      validate_non_negative_index("bsigma_K", "M", M);
      current_statement__ = 151;
      context__.validate_dims("data initialization","bsigma_K","int",
          context__.to_vec(M));
      bsigma_K = std::vector<int>(M, std::numeric_limits<int>::min());
      
      current_statement__ = 151;
      assign(bsigma_K, nil_index_list(), context__.vals_i("bsigma_K"),
        "assigning variable bsigma_K");
      current_statement__ = 151;
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        current_statement__ = 151;
        current_statement__ = 151;
        check_greater_or_equal(function__, "bsigma_K[sym1__]",
                               bsigma_K[(sym1__ - 1)], 0);}
      current_statement__ = 152;
      validate_non_negative_index("y1mu_Z", "bmu_K[1]", bmu_K[(1 - 1)]);
      current_statement__ = 153;
      validate_non_negative_index("y1mu_Z", "y_N[1]", y_N[(1 - 1)]);
      current_statement__ = 154;
      context__.validate_dims("data initialization","y1mu_Z","double",
          context__.to_vec(bmu_K[(1 - 1)], y_N[(1 - 1)]));
      y1mu_Z = std::vector<Eigen::Matrix<double, -1, 1>>(bmu_K[(1 - 1)], Eigen::Matrix<double, -1, 1>(y_N[
        (1 - 1)]));
      stan::math::fill(y1mu_Z, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> y1mu_Z_flat__;
        current_statement__ = 154;
        assign(y1mu_Z_flat__, nil_index_list(), context__.vals_r("y1mu_Z"),
          "assigning variable y1mu_Z_flat__");
        current_statement__ = 154;
        pos__ = 1;
        current_statement__ = 154;
        for (int sym1__ = 1; sym1__ <= y_N[(1 - 1)]; ++sym1__) {
          current_statement__ = 154;
          for (int sym2__ = 1; sym2__ <= bmu_K[(1 - 1)]; ++sym2__) {
            current_statement__ = 154;
            assign(y1mu_Z,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              y1mu_Z_flat__[(pos__ - 1)], "assigning variable y1mu_Z");
            current_statement__ = 154;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 155;
      validate_non_negative_index("y2mu_Z", "bmu_K[2]", bmu_K[(2 - 1)]);
      current_statement__ = 156;
      validate_non_negative_index("y2mu_Z", "y_N[2]", y_N[(2 - 1)]);
      current_statement__ = 157;
      context__.validate_dims("data initialization","y2mu_Z","double",
          context__.to_vec(bmu_K[(2 - 1)], y_N[(2 - 1)]));
      y2mu_Z = std::vector<Eigen::Matrix<double, -1, 1>>(bmu_K[(2 - 1)], Eigen::Matrix<double, -1, 1>(y_N[
        (2 - 1)]));
      stan::math::fill(y2mu_Z, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> y2mu_Z_flat__;
        current_statement__ = 157;
        assign(y2mu_Z_flat__, nil_index_list(), context__.vals_r("y2mu_Z"),
          "assigning variable y2mu_Z_flat__");
        current_statement__ = 157;
        pos__ = 1;
        current_statement__ = 157;
        for (int sym1__ = 1; sym1__ <= y_N[(2 - 1)]; ++sym1__) {
          current_statement__ = 157;
          for (int sym2__ = 1; sym2__ <= bmu_K[(2 - 1)]; ++sym2__) {
            current_statement__ = 157;
            assign(y2mu_Z,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              y2mu_Z_flat__[(pos__ - 1)], "assigning variable y2mu_Z");
            current_statement__ = 157;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 158;
      validate_non_negative_index("y1sigma_Z", "bsigma_K[1]",
                                  bsigma_K[(1 - 1)]);
      current_statement__ = 159;
      validate_non_negative_index("y1sigma_Z", "y_N[1]", y_N[(1 - 1)]);
      current_statement__ = 160;
      context__.validate_dims("data initialization","y1sigma_Z","double",
          context__.to_vec(bsigma_K[(1 - 1)], y_N[(1 - 1)]));
      y1sigma_Z = std::vector<Eigen::Matrix<double, -1, 1>>(bsigma_K[
        (1 - 1)], Eigen::Matrix<double, -1, 1>(y_N[(1 - 1)]));
      stan::math::fill(y1sigma_Z, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> y1sigma_Z_flat__;
        current_statement__ = 160;
        assign(y1sigma_Z_flat__, nil_index_list(),
          context__.vals_r("y1sigma_Z"),
          "assigning variable y1sigma_Z_flat__");
        current_statement__ = 160;
        pos__ = 1;
        current_statement__ = 160;
        for (int sym1__ = 1; sym1__ <= y_N[(1 - 1)]; ++sym1__) {
          current_statement__ = 160;
          for (int sym2__ = 1; sym2__ <= bsigma_K[(1 - 1)]; ++sym2__) {
            current_statement__ = 160;
            assign(y1sigma_Z,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              y1sigma_Z_flat__[(pos__ - 1)], "assigning variable y1sigma_Z");
            current_statement__ = 160;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 161;
      validate_non_negative_index("y2sigma_Z", "bsigma_K[2]",
                                  bsigma_K[(2 - 1)]);
      current_statement__ = 162;
      validate_non_negative_index("y2sigma_Z", "y_N[2]", y_N[(2 - 1)]);
      current_statement__ = 163;
      context__.validate_dims("data initialization","y2sigma_Z","double",
          context__.to_vec(bsigma_K[(2 - 1)], y_N[(2 - 1)]));
      y2sigma_Z = std::vector<Eigen::Matrix<double, -1, 1>>(bsigma_K[
        (2 - 1)], Eigen::Matrix<double, -1, 1>(y_N[(2 - 1)]));
      stan::math::fill(y2sigma_Z, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> y2sigma_Z_flat__;
        current_statement__ = 163;
        assign(y2sigma_Z_flat__, nil_index_list(),
          context__.vals_r("y2sigma_Z"),
          "assigning variable y2sigma_Z_flat__");
        current_statement__ = 163;
        pos__ = 1;
        current_statement__ = 163;
        for (int sym1__ = 1; sym1__ <= y_N[(2 - 1)]; ++sym1__) {
          current_statement__ = 163;
          for (int sym2__ = 1; sym2__ <= bsigma_K[(2 - 1)]; ++sym2__) {
            current_statement__ = 163;
            assign(y2sigma_Z,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              y2sigma_Z_flat__[(pos__ - 1)], "assigning variable y2sigma_Z");
            current_statement__ = 163;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 164;
      validate_non_negative_index("y1_Z_id", "y_N[1]", y_N[(1 - 1)]);
      current_statement__ = 165;
      context__.validate_dims("data initialization","y1_Z_id","int",
          context__.to_vec(y_N[(1 - 1)]));
      y1_Z_id = std::vector<int>(y_N[(1 - 1)], std::numeric_limits<int>::min());
      
      current_statement__ = 165;
      assign(y1_Z_id, nil_index_list(), context__.vals_i("y1_Z_id"),
        "assigning variable y1_Z_id");
      current_statement__ = 165;
      for (int sym1__ = 1; sym1__ <= y_N[(1 - 1)]; ++sym1__) {
        current_statement__ = 165;
        current_statement__ = 165;
        check_greater_or_equal(function__, "y1_Z_id[sym1__]",
                               y1_Z_id[(sym1__ - 1)], 0);}
      current_statement__ = 166;
      validate_non_negative_index("y2_Z_id", "y_N[2]", y_N[(2 - 1)]);
      current_statement__ = 167;
      context__.validate_dims("data initialization","y2_Z_id","int",
          context__.to_vec(y_N[(2 - 1)]));
      y2_Z_id = std::vector<int>(y_N[(2 - 1)], std::numeric_limits<int>::min());
      
      current_statement__ = 167;
      assign(y2_Z_id, nil_index_list(), context__.vals_i("y2_Z_id"),
        "assigning variable y2_Z_id");
      current_statement__ = 167;
      for (int sym1__ = 1; sym1__ <= y_N[(2 - 1)]; ++sym1__) {
        current_statement__ = 167;
        current_statement__ = 167;
        check_greater_or_equal(function__, "y2_Z_id[sym1__]",
                               y2_Z_id[(sym1__ - 1)], 0);}
      current_statement__ = 168;
      context__.validate_dims("data initialization","e_K","int",
          context__.to_vec());
      e_K = std::numeric_limits<int>::min();
      
      current_statement__ = 168;
      e_K = context__.vals_i("e_K")[(1 - 1)];
      current_statement__ = 168;
      current_statement__ = 168;
      check_greater_or_equal(function__, "e_K", e_K, 0);
      current_statement__ = 169;
      context__.validate_dims("data initialization","Npat","int",
          context__.to_vec());
      Npat = std::numeric_limits<int>::min();
      
      current_statement__ = 169;
      Npat = context__.vals_i("Npat")[(1 - 1)];
      current_statement__ = 169;
      current_statement__ = 169;
      check_greater_or_equal(function__, "Npat", Npat, 0);
      current_statement__ = 170;
      context__.validate_dims("data initialization","Nevents","int",
          context__.to_vec());
      Nevents = std::numeric_limits<int>::min();
      
      current_statement__ = 170;
      Nevents = context__.vals_i("Nevents")[(1 - 1)];
      current_statement__ = 170;
      current_statement__ = 170;
      check_greater_or_equal(function__, "Nevents", Nevents, 0);
      current_statement__ = 171;
      context__.validate_dims("data initialization","qnodes","int",
          context__.to_vec());
      qnodes = std::numeric_limits<int>::min();
      
      current_statement__ = 171;
      qnodes = context__.vals_i("qnodes")[(1 - 1)];
      current_statement__ = 171;
      current_statement__ = 171;
      check_greater_or_equal(function__, "qnodes", qnodes, 0);
      current_statement__ = 172;
      context__.validate_dims("data initialization","Npat_times_qnodes",
          "int",context__.to_vec());
      Npat_times_qnodes = std::numeric_limits<int>::min();
      
      current_statement__ = 172;
      Npat_times_qnodes = context__.vals_i("Npat_times_qnodes")[(1 - 1)];
      current_statement__ = 172;
      current_statement__ = 172;
      check_greater_or_equal(function__, "Npat_times_qnodes",
                             Npat_times_qnodes, 0);
      current_statement__ = 173;
      context__.validate_dims("data initialization","nrow_e_Xq","int",
          context__.to_vec());
      nrow_e_Xq = std::numeric_limits<int>::min();
      
      current_statement__ = 173;
      nrow_e_Xq = context__.vals_i("nrow_e_Xq")[(1 - 1)];
      current_statement__ = 173;
      current_statement__ = 173;
      check_greater_or_equal(function__, "nrow_e_Xq", nrow_e_Xq, 0);
      current_statement__ = 174;
      validate_non_negative_index("e_times", "nrow_e_Xq", nrow_e_Xq);
      current_statement__ = 175;
      context__.validate_dims("data initialization","e_times","double",
          context__.to_vec(nrow_e_Xq));
      e_times = Eigen::Matrix<double, -1, 1>(nrow_e_Xq);
      stan::math::fill(e_times, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> e_times_flat__;
        current_statement__ = 175;
        assign(e_times_flat__, nil_index_list(), context__.vals_r("e_times"),
          "assigning variable e_times_flat__");
        current_statement__ = 175;
        pos__ = 1;
        current_statement__ = 175;
        for (int sym1__ = 1; sym1__ <= nrow_e_Xq; ++sym1__) {
          current_statement__ = 175;
          assign(e_times, cons_list(index_uni(sym1__), nil_index_list()),
            e_times_flat__[(pos__ - 1)], "assigning variable e_times");
          current_statement__ = 175;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 176;
      validate_non_negative_index("e_Xq", "nrow_e_Xq", nrow_e_Xq);
      current_statement__ = 177;
      validate_non_negative_index("e_Xq", "e_K", e_K);
      current_statement__ = 178;
      context__.validate_dims("data initialization","e_Xq","double",
          context__.to_vec(nrow_e_Xq, e_K));
      e_Xq = Eigen::Matrix<double, -1, -1>(nrow_e_Xq, e_K);
      stan::math::fill(e_Xq, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> e_Xq_flat__;
        current_statement__ = 178;
        assign(e_Xq_flat__, nil_index_list(), context__.vals_r("e_Xq"),
          "assigning variable e_Xq_flat__");
        current_statement__ = 178;
        pos__ = 1;
        current_statement__ = 178;
        for (int sym1__ = 1; sym1__ <= e_K; ++sym1__) {
          current_statement__ = 178;
          for (int sym2__ = 1; sym2__ <= nrow_e_Xq; ++sym2__) {
            current_statement__ = 178;
            assign(e_Xq,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              e_Xq_flat__[(pos__ - 1)], "assigning variable e_Xq");
            current_statement__ = 178;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 179;
      validate_non_negative_index("e_Xbar", "e_K", e_K);
      current_statement__ = 180;
      context__.validate_dims("data initialization","e_Xbar","double",
          context__.to_vec(e_K));
      e_Xbar = Eigen::Matrix<double, -1, 1>(e_K);
      stan::math::fill(e_Xbar, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> e_Xbar_flat__;
        current_statement__ = 180;
        assign(e_Xbar_flat__, nil_index_list(), context__.vals_r("e_Xbar"),
          "assigning variable e_Xbar_flat__");
        current_statement__ = 180;
        pos__ = 1;
        current_statement__ = 180;
        for (int sym1__ = 1; sym1__ <= e_K; ++sym1__) {
          current_statement__ = 180;
          assign(e_Xbar, cons_list(index_uni(sym1__), nil_index_list()),
            e_Xbar_flat__[(pos__ - 1)], "assigning variable e_Xbar");
          current_statement__ = 180;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 181;
      context__.validate_dims("data initialization","basehaz_df","int",
          context__.to_vec());
      basehaz_df = std::numeric_limits<int>::min();
      
      current_statement__ = 181;
      basehaz_df = context__.vals_i("basehaz_df")[(1 - 1)];
      current_statement__ = 181;
      current_statement__ = 181;
      check_greater_or_equal(function__, "basehaz_df", basehaz_df, 0);
      current_statement__ = 182;
      validate_non_negative_index("basehaz_X", "nrow_e_Xq", nrow_e_Xq);
      current_statement__ = 183;
      validate_non_negative_index("basehaz_X", "basehaz_df", basehaz_df);
      current_statement__ = 184;
      context__.validate_dims("data initialization","basehaz_X","double",
          context__.to_vec(nrow_e_Xq, basehaz_df));
      basehaz_X = Eigen::Matrix<double, -1, -1>(nrow_e_Xq, basehaz_df);
      stan::math::fill(basehaz_X, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> basehaz_X_flat__;
        current_statement__ = 184;
        assign(basehaz_X_flat__, nil_index_list(),
          context__.vals_r("basehaz_X"),
          "assigning variable basehaz_X_flat__");
        current_statement__ = 184;
        pos__ = 1;
        current_statement__ = 184;
        for (int sym1__ = 1; sym1__ <= basehaz_df; ++sym1__) {
          current_statement__ = 184;
          for (int sym2__ = 1; sym2__ <= nrow_e_Xq; ++sym2__) {
            current_statement__ = 184;
            assign(basehaz_X,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              basehaz_X_flat__[(pos__ - 1)], "assigning variable basehaz_X");
            current_statement__ = 184;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 185;
      validate_non_negative_index("qwts", "Npat_times_qnodes",
                                  Npat_times_qnodes);
      current_statement__ = 186;
      context__.validate_dims("data initialization","qwts","double",
          context__.to_vec(Npat_times_qnodes));
      qwts = Eigen::Matrix<double, -1, 1>(Npat_times_qnodes);
      stan::math::fill(qwts, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> qwts_flat__;
        current_statement__ = 186;
        assign(qwts_flat__, nil_index_list(), context__.vals_r("qwts"),
          "assigning variable qwts_flat__");
        current_statement__ = 186;
        pos__ = 1;
        current_statement__ = 186;
        for (int sym1__ = 1; sym1__ <= Npat_times_qnodes; ++sym1__) {
          current_statement__ = 186;
          assign(qwts, cons_list(index_uni(sym1__), nil_index_list()),
            qwts_flat__[(pos__ - 1)], "assigning variable qwts");
          current_statement__ = 186;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 187;
      context__.validate_dims("data initialization","norm_const","double",
          context__.to_vec());
      norm_const = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 187;
      norm_const = context__.vals_r("norm_const")[(1 - 1)];
      current_statement__ = 188;
      context__.validate_dims("data initialization","assoc_code","double",
          context__.to_vec());
      assoc_code = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 188;
      assoc_code = context__.vals_r("assoc_code")[(1 - 1)];
      current_statement__ = 189;
      context__.validate_dims("data initialization","a_K","int",
          context__.to_vec());
      a_K = std::numeric_limits<int>::min();
      
      current_statement__ = 189;
      a_K = context__.vals_i("a_K")[(1 - 1)];
      current_statement__ = 189;
      current_statement__ = 189;
      check_greater_or_equal(function__, "a_K", a_K, 0);
      current_statement__ = 190;
      validate_non_negative_index("nrow_y_Xq", "M", M);
      current_statement__ = 191;
      context__.validate_dims("data initialization","nrow_y_Xq","int",
          context__.to_vec(M));
      nrow_y_Xq = std::vector<int>(M, std::numeric_limits<int>::min());
      
      current_statement__ = 191;
      assign(nrow_y_Xq, nil_index_list(), context__.vals_i("nrow_y_Xq"),
        "assigning variable nrow_y_Xq");
      current_statement__ = 191;
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        current_statement__ = 191;
        current_statement__ = 191;
        check_greater_or_equal(function__, "nrow_y_Xq[sym1__]",
                               nrow_y_Xq[(sym1__ - 1)], 0);}
      current_statement__ = 192;
      validate_non_negative_index("y1mu_Xq", "nrow_y_Xq[1]",
                                  nrow_y_Xq[(1 - 1)]);
      current_statement__ = 193;
      validate_non_negative_index("y1mu_Xq", "ymu_K[1]", ymu_K[(1 - 1)]);
      current_statement__ = 194;
      context__.validate_dims("data initialization","y1mu_Xq","double",
          context__.to_vec(nrow_y_Xq[(1 - 1)], ymu_K[(1 - 1)]));
      y1mu_Xq = Eigen::Matrix<double, -1, -1>(nrow_y_Xq[(1 - 1)], ymu_K[
        (1 - 1)]);
      stan::math::fill(y1mu_Xq, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> y1mu_Xq_flat__;
        current_statement__ = 194;
        assign(y1mu_Xq_flat__, nil_index_list(), context__.vals_r("y1mu_Xq"),
          "assigning variable y1mu_Xq_flat__");
        current_statement__ = 194;
        pos__ = 1;
        current_statement__ = 194;
        for (int sym1__ = 1; sym1__ <= ymu_K[(1 - 1)]; ++sym1__) {
          current_statement__ = 194;
          for (int sym2__ = 1; sym2__ <= nrow_y_Xq[(1 - 1)]; ++sym2__) {
            current_statement__ = 194;
            assign(y1mu_Xq,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              y1mu_Xq_flat__[(pos__ - 1)], "assigning variable y1mu_Xq");
            current_statement__ = 194;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 195;
      validate_non_negative_index("y2mu_Xq", "nrow_y_Xq[2]",
                                  nrow_y_Xq[(2 - 1)]);
      current_statement__ = 196;
      validate_non_negative_index("y2mu_Xq", "ymu_K[2]", ymu_K[(2 - 1)]);
      current_statement__ = 197;
      context__.validate_dims("data initialization","y2mu_Xq","double",
          context__.to_vec(nrow_y_Xq[(2 - 1)], ymu_K[(2 - 1)]));
      y2mu_Xq = Eigen::Matrix<double, -1, -1>(nrow_y_Xq[(2 - 1)], ymu_K[
        (2 - 1)]);
      stan::math::fill(y2mu_Xq, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> y2mu_Xq_flat__;
        current_statement__ = 197;
        assign(y2mu_Xq_flat__, nil_index_list(), context__.vals_r("y2mu_Xq"),
          "assigning variable y2mu_Xq_flat__");
        current_statement__ = 197;
        pos__ = 1;
        current_statement__ = 197;
        for (int sym1__ = 1; sym1__ <= ymu_K[(2 - 1)]; ++sym1__) {
          current_statement__ = 197;
          for (int sym2__ = 1; sym2__ <= nrow_y_Xq[(2 - 1)]; ++sym2__) {
            current_statement__ = 197;
            assign(y2mu_Xq,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              y2mu_Xq_flat__[(pos__ - 1)], "assigning variable y2mu_Xq");
            current_statement__ = 197;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 198;
      validate_non_negative_index("y1sigma_Xq", "nrow_y_Xq[1]",
                                  nrow_y_Xq[(1 - 1)]);
      current_statement__ = 199;
      validate_non_negative_index("y1sigma_Xq", "ysigma_K[1]",
                                  ysigma_K[(1 - 1)]);
      current_statement__ = 200;
      context__.validate_dims("data initialization","y1sigma_Xq","double",
          context__.to_vec(nrow_y_Xq[(1 - 1)], ysigma_K[(1 - 1)]));
      y1sigma_Xq = Eigen::Matrix<double, -1, -1>(nrow_y_Xq[(1 - 1)], ysigma_K[
        (1 - 1)]);
      stan::math::fill(y1sigma_Xq, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> y1sigma_Xq_flat__;
        current_statement__ = 200;
        assign(y1sigma_Xq_flat__, nil_index_list(),
          context__.vals_r("y1sigma_Xq"),
          "assigning variable y1sigma_Xq_flat__");
        current_statement__ = 200;
        pos__ = 1;
        current_statement__ = 200;
        for (int sym1__ = 1; sym1__ <= ysigma_K[(1 - 1)]; ++sym1__) {
          current_statement__ = 200;
          for (int sym2__ = 1; sym2__ <= nrow_y_Xq[(1 - 1)]; ++sym2__) {
            current_statement__ = 200;
            assign(y1sigma_Xq,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              y1sigma_Xq_flat__[(pos__ - 1)], "assigning variable y1sigma_Xq");
            current_statement__ = 200;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 201;
      validate_non_negative_index("y2sigma_Xq", "nrow_y_Xq[2]",
                                  nrow_y_Xq[(2 - 1)]);
      current_statement__ = 202;
      validate_non_negative_index("y2sigma_Xq", "ysigma_K[2]",
                                  ysigma_K[(2 - 1)]);
      current_statement__ = 203;
      context__.validate_dims("data initialization","y2sigma_Xq","double",
          context__.to_vec(nrow_y_Xq[(2 - 1)], ysigma_K[(2 - 1)]));
      y2sigma_Xq = Eigen::Matrix<double, -1, -1>(nrow_y_Xq[(2 - 1)], ysigma_K[
        (2 - 1)]);
      stan::math::fill(y2sigma_Xq, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> y2sigma_Xq_flat__;
        current_statement__ = 203;
        assign(y2sigma_Xq_flat__, nil_index_list(),
          context__.vals_r("y2sigma_Xq"),
          "assigning variable y2sigma_Xq_flat__");
        current_statement__ = 203;
        pos__ = 1;
        current_statement__ = 203;
        for (int sym1__ = 1; sym1__ <= ysigma_K[(2 - 1)]; ++sym1__) {
          current_statement__ = 203;
          for (int sym2__ = 1; sym2__ <= nrow_y_Xq[(2 - 1)]; ++sym2__) {
            current_statement__ = 203;
            assign(y2sigma_Xq,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              y2sigma_Xq_flat__[(pos__ - 1)], "assigning variable y2sigma_Xq");
            current_statement__ = 203;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 204;
      validate_non_negative_index("y1mu_Zq", "bmu_K[1]", bmu_K[(1 - 1)]);
      current_statement__ = 205;
      validate_non_negative_index("y1mu_Zq", "nrow_y_Xq[1]",
                                  nrow_y_Xq[(1 - 1)]);
      current_statement__ = 206;
      context__.validate_dims("data initialization","y1mu_Zq","double",
          context__.to_vec(bmu_K[(1 - 1)], nrow_y_Xq[(1 - 1)]));
      y1mu_Zq = std::vector<Eigen::Matrix<double, -1, 1>>(bmu_K[(1 - 1)], Eigen::Matrix<double, -1, 1>(nrow_y_Xq[
        (1 - 1)]));
      stan::math::fill(y1mu_Zq, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> y1mu_Zq_flat__;
        current_statement__ = 206;
        assign(y1mu_Zq_flat__, nil_index_list(), context__.vals_r("y1mu_Zq"),
          "assigning variable y1mu_Zq_flat__");
        current_statement__ = 206;
        pos__ = 1;
        current_statement__ = 206;
        for (int sym1__ = 1; sym1__ <= nrow_y_Xq[(1 - 1)]; ++sym1__) {
          current_statement__ = 206;
          for (int sym2__ = 1; sym2__ <= bmu_K[(1 - 1)]; ++sym2__) {
            current_statement__ = 206;
            assign(y1mu_Zq,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              y1mu_Zq_flat__[(pos__ - 1)], "assigning variable y1mu_Zq");
            current_statement__ = 206;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 207;
      validate_non_negative_index("y2mu_Zq", "bmu_K[2]", bmu_K[(2 - 1)]);
      current_statement__ = 208;
      validate_non_negative_index("y2mu_Zq", "nrow_y_Xq[2]",
                                  nrow_y_Xq[(2 - 1)]);
      current_statement__ = 209;
      context__.validate_dims("data initialization","y2mu_Zq","double",
          context__.to_vec(bmu_K[(2 - 1)], nrow_y_Xq[(2 - 1)]));
      y2mu_Zq = std::vector<Eigen::Matrix<double, -1, 1>>(bmu_K[(2 - 1)], Eigen::Matrix<double, -1, 1>(nrow_y_Xq[
        (2 - 1)]));
      stan::math::fill(y2mu_Zq, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> y2mu_Zq_flat__;
        current_statement__ = 209;
        assign(y2mu_Zq_flat__, nil_index_list(), context__.vals_r("y2mu_Zq"),
          "assigning variable y2mu_Zq_flat__");
        current_statement__ = 209;
        pos__ = 1;
        current_statement__ = 209;
        for (int sym1__ = 1; sym1__ <= nrow_y_Xq[(2 - 1)]; ++sym1__) {
          current_statement__ = 209;
          for (int sym2__ = 1; sym2__ <= bmu_K[(2 - 1)]; ++sym2__) {
            current_statement__ = 209;
            assign(y2mu_Zq,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              y2mu_Zq_flat__[(pos__ - 1)], "assigning variable y2mu_Zq");
            current_statement__ = 209;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 210;
      validate_non_negative_index("y1sigma_Zq", "bsigma_K[1]",
                                  bsigma_K[(1 - 1)]);
      current_statement__ = 211;
      validate_non_negative_index("y1sigma_Zq", "nrow_y_Xq[1]",
                                  nrow_y_Xq[(1 - 1)]);
      current_statement__ = 212;
      context__.validate_dims("data initialization","y1sigma_Zq","double",
          context__.to_vec(bsigma_K[(1 - 1)], nrow_y_Xq[(1 - 1)]));
      y1sigma_Zq = std::vector<Eigen::Matrix<double, -1, 1>>(bsigma_K[
        (1 - 1)], Eigen::Matrix<double, -1, 1>(nrow_y_Xq[(1 - 1)]));
      stan::math::fill(y1sigma_Zq, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> y1sigma_Zq_flat__;
        current_statement__ = 212;
        assign(y1sigma_Zq_flat__, nil_index_list(),
          context__.vals_r("y1sigma_Zq"),
          "assigning variable y1sigma_Zq_flat__");
        current_statement__ = 212;
        pos__ = 1;
        current_statement__ = 212;
        for (int sym1__ = 1; sym1__ <= nrow_y_Xq[(1 - 1)]; ++sym1__) {
          current_statement__ = 212;
          for (int sym2__ = 1; sym2__ <= bsigma_K[(1 - 1)]; ++sym2__) {
            current_statement__ = 212;
            assign(y1sigma_Zq,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              y1sigma_Zq_flat__[(pos__ - 1)], "assigning variable y1sigma_Zq");
            current_statement__ = 212;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 213;
      validate_non_negative_index("y2sigma_Zq", "bsigma_K[2]",
                                  bsigma_K[(2 - 1)]);
      current_statement__ = 214;
      validate_non_negative_index("y2sigma_Zq", "nrow_y_Xq[2]",
                                  nrow_y_Xq[(2 - 1)]);
      current_statement__ = 215;
      context__.validate_dims("data initialization","y2sigma_Zq","double",
          context__.to_vec(bsigma_K[(2 - 1)], nrow_y_Xq[(2 - 1)]));
      y2sigma_Zq = std::vector<Eigen::Matrix<double, -1, 1>>(bsigma_K[
        (2 - 1)], Eigen::Matrix<double, -1, 1>(nrow_y_Xq[(2 - 1)]));
      stan::math::fill(y2sigma_Zq, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> y2sigma_Zq_flat__;
        current_statement__ = 215;
        assign(y2sigma_Zq_flat__, nil_index_list(),
          context__.vals_r("y2sigma_Zq"),
          "assigning variable y2sigma_Zq_flat__");
        current_statement__ = 215;
        pos__ = 1;
        current_statement__ = 215;
        for (int sym1__ = 1; sym1__ <= nrow_y_Xq[(2 - 1)]; ++sym1__) {
          current_statement__ = 215;
          for (int sym2__ = 1; sym2__ <= bsigma_K[(2 - 1)]; ++sym2__) {
            current_statement__ = 215;
            assign(y2sigma_Zq,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              y2sigma_Zq_flat__[(pos__ - 1)], "assigning variable y2sigma_Zq");
            current_statement__ = 215;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 216;
      validate_non_negative_index("y1_Zq_id", "nrow_y_Xq[1]",
                                  nrow_y_Xq[(1 - 1)]);
      current_statement__ = 217;
      context__.validate_dims("data initialization","y1_Zq_id","int",
          context__.to_vec(nrow_y_Xq[(1 - 1)]));
      y1_Zq_id = std::vector<int>(nrow_y_Xq[(1 - 1)], std::numeric_limits<int>::min());
      
      current_statement__ = 217;
      assign(y1_Zq_id, nil_index_list(), context__.vals_i("y1_Zq_id"),
        "assigning variable y1_Zq_id");
      current_statement__ = 217;
      for (int sym1__ = 1; sym1__ <= nrow_y_Xq[(1 - 1)]; ++sym1__) {
        current_statement__ = 217;
        current_statement__ = 217;
        check_greater_or_equal(function__, "y1_Zq_id[sym1__]",
                               y1_Zq_id[(sym1__ - 1)], 0);}
      current_statement__ = 218;
      validate_non_negative_index("y2_Zq_id", "nrow_y_Xq[2]",
                                  nrow_y_Xq[(2 - 1)]);
      current_statement__ = 219;
      context__.validate_dims("data initialization","y2_Zq_id","int",
          context__.to_vec(nrow_y_Xq[(2 - 1)]));
      y2_Zq_id = std::vector<int>(nrow_y_Xq[(2 - 1)], std::numeric_limits<int>::min());
      
      current_statement__ = 219;
      assign(y2_Zq_id, nil_index_list(), context__.vals_i("y2_Zq_id"),
        "assigning variable y2_Zq_id");
      current_statement__ = 219;
      for (int sym1__ = 1; sym1__ <= nrow_y_Xq[(2 - 1)]; ++sym1__) {
        current_statement__ = 219;
        current_statement__ = 219;
        check_greater_or_equal(function__, "y2_Zq_id[sym1__]",
                               y2_Zq_id[(sym1__ - 1)], 0);}
      current_statement__ = 220;
      validate_non_negative_index("y1mu_prior_mean", "ymu_K[1]",
                                  ymu_K[(1 - 1)]);
      current_statement__ = 221;
      context__.validate_dims("data initialization","y1mu_prior_mean",
          "double",context__.to_vec(ymu_K[(1 - 1)]));
      y1mu_prior_mean = Eigen::Matrix<double, -1, 1>(ymu_K[(1 - 1)]);
      stan::math::fill(y1mu_prior_mean, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> y1mu_prior_mean_flat__;
        current_statement__ = 221;
        assign(y1mu_prior_mean_flat__, nil_index_list(),
          context__.vals_r("y1mu_prior_mean"),
          "assigning variable y1mu_prior_mean_flat__");
        current_statement__ = 221;
        pos__ = 1;
        current_statement__ = 221;
        for (int sym1__ = 1; sym1__ <= ymu_K[(1 - 1)]; ++sym1__) {
          current_statement__ = 221;
          assign(y1mu_prior_mean,
            cons_list(index_uni(sym1__), nil_index_list()),
            y1mu_prior_mean_flat__[(pos__ - 1)],
            "assigning variable y1mu_prior_mean");
          current_statement__ = 221;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 222;
      validate_non_negative_index("y2mu_prior_mean", "ymu_K[2]",
                                  ymu_K[(2 - 1)]);
      current_statement__ = 223;
      context__.validate_dims("data initialization","y2mu_prior_mean",
          "double",context__.to_vec(ymu_K[(2 - 1)]));
      y2mu_prior_mean = Eigen::Matrix<double, -1, 1>(ymu_K[(2 - 1)]);
      stan::math::fill(y2mu_prior_mean, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> y2mu_prior_mean_flat__;
        current_statement__ = 223;
        assign(y2mu_prior_mean_flat__, nil_index_list(),
          context__.vals_r("y2mu_prior_mean"),
          "assigning variable y2mu_prior_mean_flat__");
        current_statement__ = 223;
        pos__ = 1;
        current_statement__ = 223;
        for (int sym1__ = 1; sym1__ <= ymu_K[(2 - 1)]; ++sym1__) {
          current_statement__ = 223;
          assign(y2mu_prior_mean,
            cons_list(index_uni(sym1__), nil_index_list()),
            y2mu_prior_mean_flat__[(pos__ - 1)],
            "assigning variable y2mu_prior_mean");
          current_statement__ = 223;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 224;
      validate_non_negative_index("y1sigma_prior_mean", "ysigma_K[1]",
                                  ysigma_K[(1 - 1)]);
      current_statement__ = 225;
      context__.validate_dims("data initialization","y1sigma_prior_mean",
          "double",context__.to_vec(ysigma_K[(1 - 1)]));
      y1sigma_prior_mean = Eigen::Matrix<double, -1, 1>(ysigma_K[(1 - 1)]);
      stan::math::fill(y1sigma_prior_mean, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> y1sigma_prior_mean_flat__;
        current_statement__ = 225;
        assign(y1sigma_prior_mean_flat__, nil_index_list(),
          context__.vals_r("y1sigma_prior_mean"),
          "assigning variable y1sigma_prior_mean_flat__");
        current_statement__ = 225;
        pos__ = 1;
        current_statement__ = 225;
        for (int sym1__ = 1; sym1__ <= ysigma_K[(1 - 1)]; ++sym1__) {
          current_statement__ = 225;
          assign(y1sigma_prior_mean,
            cons_list(index_uni(sym1__), nil_index_list()),
            y1sigma_prior_mean_flat__[(pos__ - 1)],
            "assigning variable y1sigma_prior_mean");
          current_statement__ = 225;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 226;
      validate_non_negative_index("y2sigma_prior_mean", "ysigma_K[2]",
                                  ysigma_K[(2 - 1)]);
      current_statement__ = 227;
      context__.validate_dims("data initialization","y2sigma_prior_mean",
          "double",context__.to_vec(ysigma_K[(2 - 1)]));
      y2sigma_prior_mean = Eigen::Matrix<double, -1, 1>(ysigma_K[(2 - 1)]);
      stan::math::fill(y2sigma_prior_mean, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> y2sigma_prior_mean_flat__;
        current_statement__ = 227;
        assign(y2sigma_prior_mean_flat__, nil_index_list(),
          context__.vals_r("y2sigma_prior_mean"),
          "assigning variable y2sigma_prior_mean_flat__");
        current_statement__ = 227;
        pos__ = 1;
        current_statement__ = 227;
        for (int sym1__ = 1; sym1__ <= ysigma_K[(2 - 1)]; ++sym1__) {
          current_statement__ = 227;
          assign(y2sigma_prior_mean,
            cons_list(index_uni(sym1__), nil_index_list()),
            y2sigma_prior_mean_flat__[(pos__ - 1)],
            "assigning variable y2sigma_prior_mean");
          current_statement__ = 227;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 228;
      validate_non_negative_index("e_prior_mean", "e_K", e_K);
      current_statement__ = 229;
      context__.validate_dims("data initialization","e_prior_mean","double",
          context__.to_vec(e_K));
      e_prior_mean = Eigen::Matrix<double, -1, 1>(e_K);
      stan::math::fill(e_prior_mean, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> e_prior_mean_flat__;
        current_statement__ = 229;
        assign(e_prior_mean_flat__, nil_index_list(),
          context__.vals_r("e_prior_mean"),
          "assigning variable e_prior_mean_flat__");
        current_statement__ = 229;
        pos__ = 1;
        current_statement__ = 229;
        for (int sym1__ = 1; sym1__ <= e_K; ++sym1__) {
          current_statement__ = 229;
          assign(e_prior_mean,
            cons_list(index_uni(sym1__), nil_index_list()),
            e_prior_mean_flat__[(pos__ - 1)],
            "assigning variable e_prior_mean");
          current_statement__ = 229;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 230;
      validate_non_negative_index("a_prior_mean", "a_K", a_K);
      current_statement__ = 231;
      context__.validate_dims("data initialization","a_prior_mean","double",
          context__.to_vec(a_K));
      a_prior_mean = Eigen::Matrix<double, -1, 1>(a_K);
      stan::math::fill(a_prior_mean, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> a_prior_mean_flat__;
        current_statement__ = 231;
        assign(a_prior_mean_flat__, nil_index_list(),
          context__.vals_r("a_prior_mean"),
          "assigning variable a_prior_mean_flat__");
        current_statement__ = 231;
        pos__ = 1;
        current_statement__ = 231;
        for (int sym1__ = 1; sym1__ <= a_K; ++sym1__) {
          current_statement__ = 231;
          assign(a_prior_mean,
            cons_list(index_uni(sym1__), nil_index_list()),
            a_prior_mean_flat__[(pos__ - 1)],
            "assigning variable a_prior_mean");
          current_statement__ = 231;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 232;
      validate_non_negative_index("ymu_prior_mean_for_intercept", "M", M);
      current_statement__ = 233;
      context__.validate_dims("data initialization",
          "ymu_prior_mean_for_intercept","double",context__.to_vec(M));
      ymu_prior_mean_for_intercept = Eigen::Matrix<double, -1, 1>(M);
      stan::math::fill(ymu_prior_mean_for_intercept, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> ymu_prior_mean_for_intercept_flat__;
        current_statement__ = 233;
        assign(ymu_prior_mean_for_intercept_flat__, nil_index_list(),
          context__.vals_r("ymu_prior_mean_for_intercept"),
          "assigning variable ymu_prior_mean_for_intercept_flat__");
        current_statement__ = 233;
        pos__ = 1;
        current_statement__ = 233;
        for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
          current_statement__ = 233;
          assign(ymu_prior_mean_for_intercept,
            cons_list(index_uni(sym1__), nil_index_list()),
            ymu_prior_mean_for_intercept_flat__[(pos__ - 1)],
            "assigning variable ymu_prior_mean_for_intercept");
          current_statement__ = 233;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 234;
      validate_non_negative_index("ysigma_prior_mean_for_intercept", "M", M);
      current_statement__ = 235;
      context__.validate_dims("data initialization",
          "ysigma_prior_mean_for_intercept","double",context__.to_vec(M));
      ysigma_prior_mean_for_intercept = Eigen::Matrix<double, -1, 1>(M);
      stan::math::fill(ysigma_prior_mean_for_intercept, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> ysigma_prior_mean_for_intercept_flat__;
        current_statement__ = 235;
        assign(ysigma_prior_mean_for_intercept_flat__, nil_index_list(),
          context__.vals_r("ysigma_prior_mean_for_intercept"),
          "assigning variable ysigma_prior_mean_for_intercept_flat__");
        current_statement__ = 235;
        pos__ = 1;
        current_statement__ = 235;
        for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
          current_statement__ = 235;
          assign(ysigma_prior_mean_for_intercept,
            cons_list(index_uni(sym1__), nil_index_list()),
            ysigma_prior_mean_for_intercept_flat__[(pos__ - 1)],
            "assigning variable ysigma_prior_mean_for_intercept");
          current_statement__ = 235;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 236;
      validate_non_negative_index("e_prior_mean_for_aux", "basehaz_df",
                                  basehaz_df);
      current_statement__ = 237;
      context__.validate_dims("data initialization","e_prior_mean_for_aux",
          "double",context__.to_vec(basehaz_df));
      e_prior_mean_for_aux = Eigen::Matrix<double, -1, 1>(basehaz_df);
      stan::math::fill(e_prior_mean_for_aux, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> e_prior_mean_for_aux_flat__;
        current_statement__ = 237;
        assign(e_prior_mean_for_aux_flat__, nil_index_list(),
          context__.vals_r("e_prior_mean_for_aux"),
          "assigning variable e_prior_mean_for_aux_flat__");
        current_statement__ = 237;
        pos__ = 1;
        current_statement__ = 237;
        for (int sym1__ = 1; sym1__ <= basehaz_df; ++sym1__) {
          current_statement__ = 237;
          assign(e_prior_mean_for_aux,
            cons_list(index_uni(sym1__), nil_index_list()),
            e_prior_mean_for_aux_flat__[(pos__ - 1)],
            "assigning variable e_prior_mean_for_aux");
          current_statement__ = 237;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 238;
      validate_non_negative_index("y1mu_prior_scale", "ymu_K[1]",
                                  ymu_K[(1 - 1)]);
      current_statement__ = 239;
      context__.validate_dims("data initialization","y1mu_prior_scale",
          "double",context__.to_vec(ymu_K[(1 - 1)]));
      y1mu_prior_scale = Eigen::Matrix<double, -1, 1>(ymu_K[(1 - 1)]);
      stan::math::fill(y1mu_prior_scale, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> y1mu_prior_scale_flat__;
        current_statement__ = 239;
        assign(y1mu_prior_scale_flat__, nil_index_list(),
          context__.vals_r("y1mu_prior_scale"),
          "assigning variable y1mu_prior_scale_flat__");
        current_statement__ = 239;
        pos__ = 1;
        current_statement__ = 239;
        for (int sym1__ = 1; sym1__ <= ymu_K[(1 - 1)]; ++sym1__) {
          current_statement__ = 239;
          assign(y1mu_prior_scale,
            cons_list(index_uni(sym1__), nil_index_list()),
            y1mu_prior_scale_flat__[(pos__ - 1)],
            "assigning variable y1mu_prior_scale");
          current_statement__ = 239;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 239;
      for (int sym1__ = 1; sym1__ <= ymu_K[(1 - 1)]; ++sym1__) {
        current_statement__ = 239;
        current_statement__ = 239;
        check_greater_or_equal(function__, "y1mu_prior_scale[sym1__]",
                               y1mu_prior_scale[(sym1__ - 1)], 0);}
      current_statement__ = 240;
      validate_non_negative_index("y2mu_prior_scale", "ymu_K[2]",
                                  ymu_K[(2 - 1)]);
      current_statement__ = 241;
      context__.validate_dims("data initialization","y2mu_prior_scale",
          "double",context__.to_vec(ymu_K[(2 - 1)]));
      y2mu_prior_scale = Eigen::Matrix<double, -1, 1>(ymu_K[(2 - 1)]);
      stan::math::fill(y2mu_prior_scale, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> y2mu_prior_scale_flat__;
        current_statement__ = 241;
        assign(y2mu_prior_scale_flat__, nil_index_list(),
          context__.vals_r("y2mu_prior_scale"),
          "assigning variable y2mu_prior_scale_flat__");
        current_statement__ = 241;
        pos__ = 1;
        current_statement__ = 241;
        for (int sym1__ = 1; sym1__ <= ymu_K[(2 - 1)]; ++sym1__) {
          current_statement__ = 241;
          assign(y2mu_prior_scale,
            cons_list(index_uni(sym1__), nil_index_list()),
            y2mu_prior_scale_flat__[(pos__ - 1)],
            "assigning variable y2mu_prior_scale");
          current_statement__ = 241;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 241;
      for (int sym1__ = 1; sym1__ <= ymu_K[(2 - 1)]; ++sym1__) {
        current_statement__ = 241;
        current_statement__ = 241;
        check_greater_or_equal(function__, "y2mu_prior_scale[sym1__]",
                               y2mu_prior_scale[(sym1__ - 1)], 0);}
      current_statement__ = 242;
      validate_non_negative_index("y1sigma_prior_scale", "ysigma_K[1]",
                                  ysigma_K[(1 - 1)]);
      current_statement__ = 243;
      context__.validate_dims("data initialization","y1sigma_prior_scale",
          "double",context__.to_vec(ysigma_K[(1 - 1)]));
      y1sigma_prior_scale = Eigen::Matrix<double, -1, 1>(ysigma_K[(1 - 1)]);
      stan::math::fill(y1sigma_prior_scale, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> y1sigma_prior_scale_flat__;
        current_statement__ = 243;
        assign(y1sigma_prior_scale_flat__, nil_index_list(),
          context__.vals_r("y1sigma_prior_scale"),
          "assigning variable y1sigma_prior_scale_flat__");
        current_statement__ = 243;
        pos__ = 1;
        current_statement__ = 243;
        for (int sym1__ = 1; sym1__ <= ysigma_K[(1 - 1)]; ++sym1__) {
          current_statement__ = 243;
          assign(y1sigma_prior_scale,
            cons_list(index_uni(sym1__), nil_index_list()),
            y1sigma_prior_scale_flat__[(pos__ - 1)],
            "assigning variable y1sigma_prior_scale");
          current_statement__ = 243;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 243;
      for (int sym1__ = 1; sym1__ <= ysigma_K[(1 - 1)]; ++sym1__) {
        current_statement__ = 243;
        current_statement__ = 243;
        check_greater_or_equal(function__, "y1sigma_prior_scale[sym1__]",
                               y1sigma_prior_scale[(sym1__ - 1)], 0);}
      current_statement__ = 244;
      validate_non_negative_index("y2sigma_prior_scale", "ysigma_K[2]",
                                  ysigma_K[(2 - 1)]);
      current_statement__ = 245;
      context__.validate_dims("data initialization","y2sigma_prior_scale",
          "double",context__.to_vec(ysigma_K[(2 - 1)]));
      y2sigma_prior_scale = Eigen::Matrix<double, -1, 1>(ysigma_K[(2 - 1)]);
      stan::math::fill(y2sigma_prior_scale, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> y2sigma_prior_scale_flat__;
        current_statement__ = 245;
        assign(y2sigma_prior_scale_flat__, nil_index_list(),
          context__.vals_r("y2sigma_prior_scale"),
          "assigning variable y2sigma_prior_scale_flat__");
        current_statement__ = 245;
        pos__ = 1;
        current_statement__ = 245;
        for (int sym1__ = 1; sym1__ <= ysigma_K[(2 - 1)]; ++sym1__) {
          current_statement__ = 245;
          assign(y2sigma_prior_scale,
            cons_list(index_uni(sym1__), nil_index_list()),
            y2sigma_prior_scale_flat__[(pos__ - 1)],
            "assigning variable y2sigma_prior_scale");
          current_statement__ = 245;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 245;
      for (int sym1__ = 1; sym1__ <= ysigma_K[(2 - 1)]; ++sym1__) {
        current_statement__ = 245;
        current_statement__ = 245;
        check_greater_or_equal(function__, "y2sigma_prior_scale[sym1__]",
                               y2sigma_prior_scale[(sym1__ - 1)], 0);}
      current_statement__ = 246;
      validate_non_negative_index("e_prior_scale", "e_K", e_K);
      current_statement__ = 247;
      context__.validate_dims("data initialization","e_prior_scale","double",
          context__.to_vec(e_K));
      e_prior_scale = Eigen::Matrix<double, -1, 1>(e_K);
      stan::math::fill(e_prior_scale, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> e_prior_scale_flat__;
        current_statement__ = 247;
        assign(e_prior_scale_flat__, nil_index_list(),
          context__.vals_r("e_prior_scale"),
          "assigning variable e_prior_scale_flat__");
        current_statement__ = 247;
        pos__ = 1;
        current_statement__ = 247;
        for (int sym1__ = 1; sym1__ <= e_K; ++sym1__) {
          current_statement__ = 247;
          assign(e_prior_scale,
            cons_list(index_uni(sym1__), nil_index_list()),
            e_prior_scale_flat__[(pos__ - 1)],
            "assigning variable e_prior_scale");
          current_statement__ = 247;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 247;
      for (int sym1__ = 1; sym1__ <= e_K; ++sym1__) {
        current_statement__ = 247;
        current_statement__ = 247;
        check_greater_or_equal(function__, "e_prior_scale[sym1__]",
                               e_prior_scale[(sym1__ - 1)], 0);}
      current_statement__ = 248;
      validate_non_negative_index("a_prior_scale", "a_K", a_K);
      current_statement__ = 249;
      context__.validate_dims("data initialization","a_prior_scale","double",
          context__.to_vec(a_K));
      a_prior_scale = Eigen::Matrix<double, -1, 1>(a_K);
      stan::math::fill(a_prior_scale, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> a_prior_scale_flat__;
        current_statement__ = 249;
        assign(a_prior_scale_flat__, nil_index_list(),
          context__.vals_r("a_prior_scale"),
          "assigning variable a_prior_scale_flat__");
        current_statement__ = 249;
        pos__ = 1;
        current_statement__ = 249;
        for (int sym1__ = 1; sym1__ <= a_K; ++sym1__) {
          current_statement__ = 249;
          assign(a_prior_scale,
            cons_list(index_uni(sym1__), nil_index_list()),
            a_prior_scale_flat__[(pos__ - 1)],
            "assigning variable a_prior_scale");
          current_statement__ = 249;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 249;
      for (int sym1__ = 1; sym1__ <= a_K; ++sym1__) {
        current_statement__ = 249;
        current_statement__ = 249;
        check_greater_or_equal(function__, "a_prior_scale[sym1__]",
                               a_prior_scale[(sym1__ - 1)], 0);}
      current_statement__ = 250;
      validate_non_negative_index("ymu_prior_scale_for_intercept", "M", M);
      current_statement__ = 251;
      context__.validate_dims("data initialization",
          "ymu_prior_scale_for_intercept","double",context__.to_vec(M));
      ymu_prior_scale_for_intercept = Eigen::Matrix<double, -1, 1>(M);
      stan::math::fill(ymu_prior_scale_for_intercept, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> ymu_prior_scale_for_intercept_flat__;
        current_statement__ = 251;
        assign(ymu_prior_scale_for_intercept_flat__, nil_index_list(),
          context__.vals_r("ymu_prior_scale_for_intercept"),
          "assigning variable ymu_prior_scale_for_intercept_flat__");
        current_statement__ = 251;
        pos__ = 1;
        current_statement__ = 251;
        for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
          current_statement__ = 251;
          assign(ymu_prior_scale_for_intercept,
            cons_list(index_uni(sym1__), nil_index_list()),
            ymu_prior_scale_for_intercept_flat__[(pos__ - 1)],
            "assigning variable ymu_prior_scale_for_intercept");
          current_statement__ = 251;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 251;
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        current_statement__ = 251;
        current_statement__ = 251;
        check_greater_or_equal(function__,
                               "ymu_prior_scale_for_intercept[sym1__]",
                               ymu_prior_scale_for_intercept[(sym1__ - 1)], 0);
      }
      current_statement__ = 252;
      validate_non_negative_index("ysigma_prior_scale_for_intercept", "M", M);
      current_statement__ = 253;
      context__.validate_dims("data initialization",
          "ysigma_prior_scale_for_intercept","double",context__.to_vec(M));
      ysigma_prior_scale_for_intercept = Eigen::Matrix<double, -1, 1>(M);
      stan::math::fill(ysigma_prior_scale_for_intercept, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> ysigma_prior_scale_for_intercept_flat__;
        current_statement__ = 253;
        assign(ysigma_prior_scale_for_intercept_flat__, nil_index_list(),
          context__.vals_r("ysigma_prior_scale_for_intercept"),
          "assigning variable ysigma_prior_scale_for_intercept_flat__");
        current_statement__ = 253;
        pos__ = 1;
        current_statement__ = 253;
        for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
          current_statement__ = 253;
          assign(ysigma_prior_scale_for_intercept,
            cons_list(index_uni(sym1__), nil_index_list()),
            ysigma_prior_scale_for_intercept_flat__[(pos__ - 1)],
            "assigning variable ysigma_prior_scale_for_intercept");
          current_statement__ = 253;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 253;
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        current_statement__ = 253;
        current_statement__ = 253;
        check_greater_or_equal(function__,
                               "ysigma_prior_scale_for_intercept[sym1__]",
                               ysigma_prior_scale_for_intercept[(sym1__ - 1)],
                               0);}
      current_statement__ = 254;
      validate_non_negative_index("e_prior_scale_for_aux", "basehaz_df",
                                  basehaz_df);
      current_statement__ = 255;
      context__.validate_dims("data initialization","e_prior_scale_for_aux",
          "double",context__.to_vec(basehaz_df));
      e_prior_scale_for_aux = Eigen::Matrix<double, -1, 1>(basehaz_df);
      stan::math::fill(e_prior_scale_for_aux, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> e_prior_scale_for_aux_flat__;
        current_statement__ = 255;
        assign(e_prior_scale_for_aux_flat__, nil_index_list(),
          context__.vals_r("e_prior_scale_for_aux"),
          "assigning variable e_prior_scale_for_aux_flat__");
        current_statement__ = 255;
        pos__ = 1;
        current_statement__ = 255;
        for (int sym1__ = 1; sym1__ <= basehaz_df; ++sym1__) {
          current_statement__ = 255;
          assign(e_prior_scale_for_aux,
            cons_list(index_uni(sym1__), nil_index_list()),
            e_prior_scale_for_aux_flat__[(pos__ - 1)],
            "assigning variable e_prior_scale_for_aux");
          current_statement__ = 255;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 255;
      for (int sym1__ = 1; sym1__ <= basehaz_df; ++sym1__) {
        current_statement__ = 255;
        current_statement__ = 255;
        check_greater_or_equal(function__, "e_prior_scale_for_aux[sym1__]",
                               e_prior_scale_for_aux[(sym1__ - 1)], 0);}
      current_statement__ = 256;
      validate_non_negative_index("b_prior_scale", "b_K", b_K);
      current_statement__ = 257;
      context__.validate_dims("data initialization","b_prior_scale","double",
          context__.to_vec(b_K));
      b_prior_scale = Eigen::Matrix<double, -1, 1>(b_K);
      stan::math::fill(b_prior_scale, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> b_prior_scale_flat__;
        current_statement__ = 257;
        assign(b_prior_scale_flat__, nil_index_list(),
          context__.vals_r("b_prior_scale"),
          "assigning variable b_prior_scale_flat__");
        current_statement__ = 257;
        pos__ = 1;
        current_statement__ = 257;
        for (int sym1__ = 1; sym1__ <= b_K; ++sym1__) {
          current_statement__ = 257;
          assign(b_prior_scale,
            cons_list(index_uni(sym1__), nil_index_list()),
            b_prior_scale_flat__[(pos__ - 1)],
            "assigning variable b_prior_scale");
          current_statement__ = 257;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 257;
      for (int sym1__ = 1; sym1__ <= b_K; ++sym1__) {
        current_statement__ = 257;
        current_statement__ = 257;
        check_greater_or_equal(function__, "b_prior_scale[sym1__]",
                               b_prior_scale[(sym1__ - 1)], 0);}
      current_statement__ = 258;
      validate_non_negative_index("b_prior_df", "b_K", b_K);
      current_statement__ = 259;
      context__.validate_dims("data initialization","b_prior_df","double",
          context__.to_vec(b_K));
      b_prior_df = Eigen::Matrix<double, -1, 1>(b_K);
      stan::math::fill(b_prior_df, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> b_prior_df_flat__;
        current_statement__ = 259;
        assign(b_prior_df_flat__, nil_index_list(),
          context__.vals_r("b_prior_df"),
          "assigning variable b_prior_df_flat__");
        current_statement__ = 259;
        pos__ = 1;
        current_statement__ = 259;
        for (int sym1__ = 1; sym1__ <= b_K; ++sym1__) {
          current_statement__ = 259;
          assign(b_prior_df, cons_list(index_uni(sym1__), nil_index_list()),
            b_prior_df_flat__[(pos__ - 1)], "assigning variable b_prior_df");
          current_statement__ = 259;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 259;
      for (int sym1__ = 1; sym1__ <= b_K; ++sym1__) {
        current_statement__ = 259;
        current_statement__ = 259;
        check_greater_or_equal(function__, "b_prior_df[sym1__]",
                               b_prior_df[(sym1__ - 1)], 0);}
      current_statement__ = 260;
      context__.validate_dims("data initialization","b_prior_regularization",
          "double",context__.to_vec());
      b_prior_regularization = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 260;
      b_prior_regularization = context__.vals_r("b_prior_regularization")[
          (1 - 1)];
      current_statement__ = 260;
      current_statement__ = 260;
      check_greater_or_equal(function__, "b_prior_regularization",
                             b_prior_regularization, 0);
      current_statement__ = 261;
      validate_non_negative_index("b_KM", "2 * M", (2 * M));
      current_statement__ = 262;
      b_KM = std::vector<int>((2 * M), std::numeric_limits<int>::min());
      
      current_statement__ = 262;
      assign(b_KM, nil_index_list(), std::vector<int>{bmu_K[(1 - 1)],
        bsigma_K[(1 - 1)], bmu_K[(2 - 1)], bsigma_K[(2 - 1)]},
        "assigning variable b_KM");
      current_statement__ = 263;
      validate_non_negative_index("b_cov_idx", "b_K + choose(b_K, 2)",
                                  (b_K + choose(b_K, 2)));
      current_statement__ = 264;
      b_cov_idx = std::vector<int>((b_K + choose(b_K, 2)), std::numeric_limits<int>::min());
      
      current_statement__ = 266;
      if (logical_gt(b_K, 0)) {
        current_statement__ = 265;
        assign(b_cov_idx, nil_index_list(),
          lower_tri_indices(b_K, pstream__), "assigning variable b_cov_idx");
      } 
      current_statement__ = 262;
      for (int sym1__ = 1; sym1__ <= (2 * M); ++sym1__) {
        current_statement__ = 262;
        current_statement__ = 262;
        check_greater_or_equal(function__, "b_KM[sym1__]",
                               b_KM[(sym1__ - 1)], 0);}
      current_statement__ = 267;
      y1mu_z_beta_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 267;
      y1mu_z_beta_1dim__ = ymu_K[(1 - 1)];
      current_statement__ = 267;
      validate_non_negative_index("y1mu_z_beta", "ymu_K[1]",
                                  y1mu_z_beta_1dim__);
      current_statement__ = 268;
      y1sigma_z_beta_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 268;
      y1sigma_z_beta_1dim__ = ysigma_K[(1 - 1)];
      current_statement__ = 268;
      validate_non_negative_index("y1sigma_z_beta", "ysigma_K[1]",
                                  y1sigma_z_beta_1dim__);
      current_statement__ = 269;
      y2mu_z_beta_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 269;
      y2mu_z_beta_1dim__ = ymu_K[(2 - 1)];
      current_statement__ = 269;
      validate_non_negative_index("y2mu_z_beta", "ymu_K[2]",
                                  y2mu_z_beta_1dim__);
      current_statement__ = 270;
      y2sigma_z_beta_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 270;
      y2sigma_z_beta_1dim__ = ysigma_K[(2 - 1)];
      current_statement__ = 270;
      validate_non_negative_index("y2sigma_z_beta", "ysigma_K[2]",
                                  y2sigma_z_beta_1dim__);
      current_statement__ = 271;
      validate_non_negative_index("b_sd", "b_K", b_K);
      current_statement__ = 272;
      validate_non_negative_index("z_b_mat", "b_K", b_K);
      current_statement__ = 273;
      validate_non_negative_index("z_b_mat", "b_N", b_N);
      current_statement__ = 274;
      b_cholesky_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 274;
      b_cholesky_1dim__ = (logical_gt(b_K, 1) ? b_K : 0);
      current_statement__ = 274;
      validate_non_negative_index("b_cholesky", "b_K > 1 ? b_K : 0",
                                  b_cholesky_1dim__);
      current_statement__ = 274;
      b_cholesky_2dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 274;
      b_cholesky_2dim__ = (logical_gt(b_K, 1) ? b_K : 0);
      current_statement__ = 274;
      validate_non_negative_index("b_cholesky", "b_K > 1 ? b_K : 0",
                                  b_cholesky_2dim__);
      current_statement__ = 275;
      validate_non_negative_index("e_z_beta", "e_K", e_K);
      current_statement__ = 276;
      validate_non_negative_index("a_z_beta", "a_K", a_K);
      current_statement__ = 277;
      validate_non_negative_index("e_aux_unscaled", "basehaz_df", basehaz_df);
      current_statement__ = 278;
      y1mu_beta_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 278;
      y1mu_beta_1dim__ = ymu_K[(1 - 1)];
      current_statement__ = 278;
      validate_non_negative_index("y1mu_beta", "ymu_K[1]", y1mu_beta_1dim__);
      current_statement__ = 279;
      y1sigma_beta_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 279;
      y1sigma_beta_1dim__ = ysigma_K[(1 - 1)];
      current_statement__ = 279;
      validate_non_negative_index("y1sigma_beta", "ysigma_K[1]",
                                  y1sigma_beta_1dim__);
      current_statement__ = 280;
      y2mu_beta_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 280;
      y2mu_beta_1dim__ = ymu_K[(2 - 1)];
      current_statement__ = 280;
      validate_non_negative_index("y2mu_beta", "ymu_K[2]", y2mu_beta_1dim__);
      current_statement__ = 281;
      y2sigma_beta_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 281;
      y2sigma_beta_1dim__ = ysigma_K[(2 - 1)];
      current_statement__ = 281;
      validate_non_negative_index("y2sigma_beta", "ysigma_K[2]",
                                  y2sigma_beta_1dim__);
      current_statement__ = 282;
      validate_non_negative_index("e_beta", "e_K", e_K);
      current_statement__ = 283;
      validate_non_negative_index("a_beta", "a_K", a_K);
      current_statement__ = 284;
      validate_non_negative_index("e_aux", "basehaz_df", basehaz_df);
      current_statement__ = 285;
      validate_non_negative_index("b_mat", "b_N", b_N);
      current_statement__ = 286;
      validate_non_negative_index("b_mat", "b_K", b_K);
      current_statement__ = 287;
      b_cov_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 287;
      b_cov_1dim__ = stan::math::size(b_cov_idx);
      current_statement__ = 287;
      validate_non_negative_index("b_cov", "size(b_cov_idx)", b_cov_1dim__);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 0U;
    
    try {
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += y1mu_z_beta_1dim__;
      num_params_r__ += y1sigma_z_beta_1dim__;
      num_params_r__ += y2mu_z_beta_1dim__;
      num_params_r__ += y2sigma_z_beta_1dim__;
      num_params_r__ += b_K;
      num_params_r__ += b_K * b_N;
      num_params_r__ += ((b_cholesky_1dim__ * (b_cholesky_1dim__ - 1)) / 2);
      num_params_r__ += e_K;
      num_params_r__ += a_K;
      num_params_r__ += basehaz_df;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
  }
  template <bool propto__, bool jacobian__, typename VecR, typename VecI, stan::require_vector_like_t<VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    static const char* function__ = "model_jmwiv_namespace::log_prob";
(void) function__;  // suppress unused var warning
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    
    try {
      local_scalar_t__ y1mu_gamma;
      y1mu_gamma = DUMMY_VAR__;
      
      current_statement__ = 1;
      y1mu_gamma = in__.scalar();
      local_scalar_t__ y1sigma_gamma;
      y1sigma_gamma = DUMMY_VAR__;
      
      current_statement__ = 2;
      y1sigma_gamma = in__.scalar();
      local_scalar_t__ y2mu_gamma;
      y2mu_gamma = DUMMY_VAR__;
      
      current_statement__ = 3;
      y2mu_gamma = in__.scalar();
      local_scalar_t__ y2sigma_gamma;
      y2sigma_gamma = DUMMY_VAR__;
      
      current_statement__ = 4;
      y2sigma_gamma = in__.scalar();
      Eigen::Matrix<local_scalar_t__, -1, 1> y1mu_z_beta;
      y1mu_z_beta = Eigen::Matrix<local_scalar_t__, -1, 1>(y1mu_z_beta_1dim__);
      stan::math::fill(y1mu_z_beta, DUMMY_VAR__);
      
      current_statement__ = 5;
      y1mu_z_beta = in__.vector(y1mu_z_beta_1dim__);
      Eigen::Matrix<local_scalar_t__, -1, 1> y1sigma_z_beta;
      y1sigma_z_beta = Eigen::Matrix<local_scalar_t__, -1, 1>(y1sigma_z_beta_1dim__);
      stan::math::fill(y1sigma_z_beta, DUMMY_VAR__);
      
      current_statement__ = 6;
      y1sigma_z_beta = in__.vector(y1sigma_z_beta_1dim__);
      Eigen::Matrix<local_scalar_t__, -1, 1> y2mu_z_beta;
      y2mu_z_beta = Eigen::Matrix<local_scalar_t__, -1, 1>(y2mu_z_beta_1dim__);
      stan::math::fill(y2mu_z_beta, DUMMY_VAR__);
      
      current_statement__ = 7;
      y2mu_z_beta = in__.vector(y2mu_z_beta_1dim__);
      Eigen::Matrix<local_scalar_t__, -1, 1> y2sigma_z_beta;
      y2sigma_z_beta = Eigen::Matrix<local_scalar_t__, -1, 1>(y2sigma_z_beta_1dim__);
      stan::math::fill(y2sigma_z_beta, DUMMY_VAR__);
      
      current_statement__ = 8;
      y2sigma_z_beta = in__.vector(y2sigma_z_beta_1dim__);
      Eigen::Matrix<local_scalar_t__, -1, 1> b_sd;
      b_sd = Eigen::Matrix<local_scalar_t__, -1, 1>(b_K);
      stan::math::fill(b_sd, DUMMY_VAR__);
      
      current_statement__ = 9;
      b_sd = in__.vector(b_K);
      current_statement__ = 9;
      for (int sym1__ = 1; sym1__ <= b_K; ++sym1__) {
        current_statement__ = 9;
        if (jacobian__) {
          current_statement__ = 9;
          assign(b_sd, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(b_sd[(sym1__ - 1)], 0, lp__),
            "assigning variable b_sd");
        } else {
          current_statement__ = 9;
          assign(b_sd, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(b_sd[(sym1__ - 1)], 0),
            "assigning variable b_sd");
        }}
      Eigen::Matrix<local_scalar_t__, -1, -1> z_b_mat;
      z_b_mat = Eigen::Matrix<local_scalar_t__, -1, -1>(b_K, b_N);
      stan::math::fill(z_b_mat, DUMMY_VAR__);
      
      current_statement__ = 10;
      z_b_mat = in__.matrix(b_K, b_N);
      Eigen::Matrix<local_scalar_t__, -1, -1> b_cholesky;
      b_cholesky = Eigen::Matrix<local_scalar_t__, -1, -1>(b_cholesky_1dim__, b_cholesky_2dim__);
      stan::math::fill(b_cholesky, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, 1> b_cholesky_in__;
      b_cholesky_in__ = Eigen::Matrix<local_scalar_t__, -1, 1>(((b_cholesky_1dim__
                                                                  *
                                                                  (b_cholesky_1dim__
                                                                    - 1)) /
                                                                 2));
      stan::math::fill(b_cholesky_in__, DUMMY_VAR__);
      
      current_statement__ = 11;
      b_cholesky_in__ = in__.vector(
                          ((b_cholesky_1dim__ * (b_cholesky_1dim__ - 1)) / 2));
      current_statement__ = 11;
      if (jacobian__) {
        current_statement__ = 11;
        assign(b_cholesky, nil_index_list(),
          stan::math::cholesky_corr_constrain(b_cholesky_in__,
            b_cholesky_1dim__, lp__), "assigning variable b_cholesky");
      } else {
        current_statement__ = 11;
        assign(b_cholesky, nil_index_list(),
          stan::math::cholesky_corr_constrain(b_cholesky_in__,
            b_cholesky_1dim__), "assigning variable b_cholesky");
      }
      Eigen::Matrix<local_scalar_t__, -1, 1> e_z_beta;
      e_z_beta = Eigen::Matrix<local_scalar_t__, -1, 1>(e_K);
      stan::math::fill(e_z_beta, DUMMY_VAR__);
      
      current_statement__ = 12;
      e_z_beta = in__.vector(e_K);
      Eigen::Matrix<local_scalar_t__, -1, 1> a_z_beta;
      a_z_beta = Eigen::Matrix<local_scalar_t__, -1, 1>(a_K);
      stan::math::fill(a_z_beta, DUMMY_VAR__);
      
      current_statement__ = 13;
      a_z_beta = in__.vector(a_K);
      Eigen::Matrix<local_scalar_t__, -1, 1> e_aux_unscaled;
      e_aux_unscaled = Eigen::Matrix<local_scalar_t__, -1, 1>(basehaz_df);
      stan::math::fill(e_aux_unscaled, DUMMY_VAR__);
      
      current_statement__ = 14;
      e_aux_unscaled = in__.vector(basehaz_df);
      Eigen::Matrix<local_scalar_t__, -1, 1> y1mu_beta;
      y1mu_beta = Eigen::Matrix<local_scalar_t__, -1, 1>(y1mu_beta_1dim__);
      stan::math::fill(y1mu_beta, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, 1> y1sigma_beta;
      y1sigma_beta = Eigen::Matrix<local_scalar_t__, -1, 1>(y1sigma_beta_1dim__);
      stan::math::fill(y1sigma_beta, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, 1> y2mu_beta;
      y2mu_beta = Eigen::Matrix<local_scalar_t__, -1, 1>(y2mu_beta_1dim__);
      stan::math::fill(y2mu_beta, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, 1> y2sigma_beta;
      y2sigma_beta = Eigen::Matrix<local_scalar_t__, -1, 1>(y2sigma_beta_1dim__);
      stan::math::fill(y2sigma_beta, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, 1> e_beta;
      e_beta = Eigen::Matrix<local_scalar_t__, -1, 1>(e_K);
      stan::math::fill(e_beta, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, 1> a_beta;
      a_beta = Eigen::Matrix<local_scalar_t__, -1, 1>(a_K);
      stan::math::fill(a_beta, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, 1> e_aux;
      e_aux = Eigen::Matrix<local_scalar_t__, -1, 1>(basehaz_df);
      stan::math::fill(e_aux, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, -1> b_mat;
      b_mat = Eigen::Matrix<local_scalar_t__, -1, -1>(b_N, b_K);
      stan::math::fill(b_mat, DUMMY_VAR__);
      
      current_statement__ = 23;
      assign(y1mu_beta, nil_index_list(),
        add(elt_multiply(y1mu_z_beta, y1mu_prior_scale), y1mu_prior_mean),
        "assigning variable y1mu_beta");
      current_statement__ = 24;
      assign(y2mu_beta, nil_index_list(),
        add(elt_multiply(y2mu_z_beta, y2mu_prior_scale), y2mu_prior_mean),
        "assigning variable y2mu_beta");
      current_statement__ = 25;
      assign(y1sigma_beta, nil_index_list(),
        add(elt_multiply(y1sigma_z_beta, y1sigma_prior_scale),
          y1sigma_prior_mean), "assigning variable y1sigma_beta");
      current_statement__ = 26;
      assign(y2sigma_beta, nil_index_list(),
        add(elt_multiply(y2sigma_z_beta, y2sigma_prior_scale),
          y2sigma_prior_mean), "assigning variable y2sigma_beta");
      current_statement__ = 27;
      assign(e_beta, nil_index_list(),
        add(elt_multiply(e_z_beta, e_prior_scale), e_prior_mean),
        "assigning variable e_beta");
      current_statement__ = 28;
      assign(a_beta, nil_index_list(),
        add(elt_multiply(a_z_beta, a_prior_scale), a_prior_mean),
        "assigning variable a_beta");
      current_statement__ = 29;
      assign(e_aux, nil_index_list(),
        add(elt_multiply(e_aux_unscaled, e_prior_scale_for_aux),
          e_prior_mean_for_aux), "assigning variable e_aux");
      current_statement__ = 33;
      if (logical_eq(b_K, 1)) {
        current_statement__ = 32;
        assign(b_mat, nil_index_list(),
          transpose(multiply(b_sd[(1 - 1)], z_b_mat)),
          "assigning variable b_mat");
      } else {
        current_statement__ = 31;
        if (logical_gt(b_K, 1)) {
          current_statement__ = 30;
          assign(b_mat, nil_index_list(),
            transpose(multiply(diag_pre_multiply(b_sd, b_cholesky), z_b_mat)),
            "assigning variable b_mat");
        } 
      }
      {
        {
          current_statement__ = 48;
          validate_non_negative_index("y1mu_eta", "y_N[1]", y_N[(1 - 1)]);
          Eigen::Matrix<local_scalar_t__, -1, 1> y1mu_eta;
          y1mu_eta = Eigen::Matrix<local_scalar_t__, -1, 1>(y_N[(1 - 1)]);
          stan::math::fill(y1mu_eta, DUMMY_VAR__);
          
          current_statement__ = 50;
          validate_non_negative_index("y1sigma_eta", "y_N[1]", y_N[(1 - 1)]);
          Eigen::Matrix<local_scalar_t__, -1, 1> y1sigma_eta;
          y1sigma_eta = Eigen::Matrix<local_scalar_t__, -1, 1>(y_N[(1 - 1)]);
          stan::math::fill(y1sigma_eta, DUMMY_VAR__);
          
          current_statement__ = 52;
          validate_non_negative_index("y2mu_eta", "y_N[2]", y_N[(2 - 1)]);
          Eigen::Matrix<local_scalar_t__, -1, 1> y2mu_eta;
          y2mu_eta = Eigen::Matrix<local_scalar_t__, -1, 1>(y_N[(2 - 1)]);
          stan::math::fill(y2mu_eta, DUMMY_VAR__);
          
          current_statement__ = 54;
          validate_non_negative_index("y2sigma_eta", "y_N[2]", y_N[(2 - 1)]);
          Eigen::Matrix<local_scalar_t__, -1, 1> y2sigma_eta;
          y2sigma_eta = Eigen::Matrix<local_scalar_t__, -1, 1>(y_N[(2 - 1)]);
          stan::math::fill(y2sigma_eta, DUMMY_VAR__);
          
          current_statement__ = 56;
          assign(y1mu_eta, nil_index_list(),
            evaluate_eta(y1mu_X, y1mu_Z, y1_Z_id, y1mu_gamma, y1mu_beta,
              b_mat, 0, pstream__), "assigning variable y1mu_eta");
          current_statement__ = 57;
          assign(y2mu_eta, nil_index_list(),
            evaluate_eta(y2mu_X, y2mu_Z, y2_Z_id, y2mu_gamma, y2mu_beta,
              b_mat, (b_KM[(1 - 1)] + b_KM[(2 - 1)]), pstream__),
            "assigning variable y2mu_eta");
          current_statement__ = 58;
          assign(y1sigma_eta, nil_index_list(),
            evaluate_eta(y1sigma_X, y1sigma_Z, y1_Z_id, y1sigma_gamma,
              y1sigma_beta, b_mat, b_KM[(1 - 1)], pstream__),
            "assigning variable y1sigma_eta");
          current_statement__ = 59;
          assign(y2sigma_eta, nil_index_list(),
            evaluate_eta(y2sigma_X, y2sigma_Z, y2_Z_id, y2sigma_gamma,
              y2sigma_beta, b_mat,
              ((b_KM[(1 - 1)] + b_KM[(2 - 1)]) + b_KM[(3 - 1)]), pstream__),
            "assigning variable y2sigma_eta");
          current_statement__ = 60;
          lp_accum__.add(
            normal_lpdf<false>(y1, y1mu_eta, stan::math::exp(y1sigma_eta)));
          current_statement__ = 61;
          lp_accum__.add(
            normal_lpdf<false>(y2, y2mu_eta, stan::math::exp(y2sigma_eta)));
        }
        {
          current_statement__ = 63;
          validate_non_negative_index("e_eta_q", "nrow_e_Xq", nrow_e_Xq);
          Eigen::Matrix<local_scalar_t__, -1, 1> e_eta_q;
          e_eta_q = Eigen::Matrix<local_scalar_t__, -1, 1>(nrow_e_Xq);
          stan::math::fill(e_eta_q, DUMMY_VAR__);
          
          current_statement__ = 65;
          validate_non_negative_index("log_basehaz", "nrow_e_Xq", nrow_e_Xq);
          Eigen::Matrix<local_scalar_t__, -1, 1> log_basehaz;
          log_basehaz = Eigen::Matrix<local_scalar_t__, -1, 1>(nrow_e_Xq);
          stan::math::fill(log_basehaz, DUMMY_VAR__);
          
          current_statement__ = 67;
          validate_non_negative_index("log_haz_q", "nrow_e_Xq", nrow_e_Xq);
          Eigen::Matrix<local_scalar_t__, -1, 1> log_haz_q;
          log_haz_q = Eigen::Matrix<local_scalar_t__, -1, 1>(nrow_e_Xq);
          stan::math::fill(log_haz_q, DUMMY_VAR__);
          
          current_statement__ = 69;
          validate_non_negative_index("log_haz_etimes", "Nevents", Nevents);
          Eigen::Matrix<local_scalar_t__, -1, 1> log_haz_etimes;
          log_haz_etimes = Eigen::Matrix<local_scalar_t__, -1, 1>(Nevents);
          stan::math::fill(log_haz_etimes, DUMMY_VAR__);
          
          current_statement__ = 71;
          validate_non_negative_index("log_haz_qtimes", "Npat_times_qnodes",
                                      Npat_times_qnodes);
          Eigen::Matrix<local_scalar_t__, -1, 1> log_haz_qtimes;
          log_haz_qtimes = Eigen::Matrix<local_scalar_t__, -1, 1>(Npat_times_qnodes);
          stan::math::fill(log_haz_qtimes, DUMMY_VAR__);
          
          current_statement__ = 73;
          assign(e_eta_q, nil_index_list(), multiply(e_Xq, e_beta),
            "assigning variable e_eta_q");
          current_statement__ = 93;
          if (logical_eq(assoc_code, 0)) {
            current_statement__ = 92;
            assign(e_eta_q, nil_index_list(),
              add(stan::model::deep_copy(e_eta_q),
                add(
                  add(
                    add(
                      multiply(a_beta[(1 - 1)],
                        rvalue(b_mat,
                          cons_list(index_multi(y1_Zq_id),
                            cons_list(index_uni(1), nil_index_list())),
                          "b_mat")),
                      multiply(a_beta[(2 - 1)],
                        rvalue(b_mat,
                          cons_list(index_multi(y1_Zq_id),
                            cons_list(index_uni(2), nil_index_list())),
                          "b_mat"))),
                    multiply(a_beta[(3 - 1)],
                      rvalue(b_mat,
                        cons_list(index_multi(y2_Zq_id),
                          cons_list(index_uni(3), nil_index_list())),
                        "b_mat"))),
                  multiply(a_beta[(4 - 1)],
                    rvalue(b_mat,
                      cons_list(index_multi(y2_Zq_id),
                        cons_list(index_uni(4), nil_index_list())), "b_mat")))),
              "assigning variable e_eta_q");
          } else {
            current_statement__ = 74;
            validate_non_negative_index("y1mu_eta_q", "nrow_y_Xq[1]",
                                        nrow_y_Xq[(1 - 1)]);
            Eigen::Matrix<local_scalar_t__, -1, 1> y1mu_eta_q;
            y1mu_eta_q = Eigen::Matrix<local_scalar_t__, -1, 1>(nrow_y_Xq[
              (1 - 1)]);
            stan::math::fill(y1mu_eta_q, DUMMY_VAR__);
            
            current_statement__ = 76;
            validate_non_negative_index("y2mu_eta_q", "nrow_y_Xq[2]",
                                        nrow_y_Xq[(2 - 1)]);
            Eigen::Matrix<local_scalar_t__, -1, 1> y2mu_eta_q;
            y2mu_eta_q = Eigen::Matrix<local_scalar_t__, -1, 1>(nrow_y_Xq[
              (2 - 1)]);
            stan::math::fill(y2mu_eta_q, DUMMY_VAR__);
            
            current_statement__ = 78;
            validate_non_negative_index("y1sigma_eta_q", "nrow_y_Xq[1]",
                                        nrow_y_Xq[(1 - 1)]);
            Eigen::Matrix<local_scalar_t__, -1, 1> y1sigma_eta_q;
            y1sigma_eta_q = Eigen::Matrix<local_scalar_t__, -1, 1>(nrow_y_Xq[
              (1 - 1)]);
            stan::math::fill(y1sigma_eta_q, DUMMY_VAR__);
            
            current_statement__ = 80;
            validate_non_negative_index("y2sigma_eta_q", "nrow_y_Xq[2]",
                                        nrow_y_Xq[(2 - 1)]);
            Eigen::Matrix<local_scalar_t__, -1, 1> y2sigma_eta_q;
            y2sigma_eta_q = Eigen::Matrix<local_scalar_t__, -1, 1>(nrow_y_Xq[
              (2 - 1)]);
            stan::math::fill(y2sigma_eta_q, DUMMY_VAR__);
            
            current_statement__ = 82;
            assign(y1mu_eta_q, nil_index_list(),
              evaluate_eta(y1mu_Xq, y1mu_Zq, y1_Zq_id, y1mu_gamma, y1mu_beta,
                b_mat, 0, pstream__), "assigning variable y1mu_eta_q");
            current_statement__ = 83;
            assign(y2mu_eta_q, nil_index_list(),
              evaluate_eta(y2mu_Xq, y2mu_Zq, y2_Zq_id, y2mu_gamma, y2mu_beta,
                b_mat, (b_KM[(1 - 1)] + b_KM[(2 - 1)]), pstream__),
              "assigning variable y2mu_eta_q");
            current_statement__ = 84;
            assign(y1sigma_eta_q, nil_index_list(),
              evaluate_eta(y1sigma_Xq, y1sigma_Zq, y1_Zq_id, y1sigma_gamma,
                y1sigma_beta, b_mat, b_KM[(1 - 1)], pstream__),
              "assigning variable y1sigma_eta_q");
            current_statement__ = 85;
            assign(y2sigma_eta_q, nil_index_list(),
              evaluate_eta(y2sigma_Xq, y2sigma_Zq, y2_Zq_id, y2sigma_gamma,
                y2sigma_beta, b_mat,
                ((b_KM[(1 - 1)] + b_KM[(2 - 1)]) + b_KM[(3 - 1)]), pstream__),
              "assigning variable y2sigma_eta_q");
            current_statement__ = 89;
            if (logical_eq(assoc_code, 2)) {
              current_statement__ = 86;
              assign(y1sigma_eta_q, nil_index_list(),
                stan::math::exp(stan::model::deep_copy(y1sigma_eta_q)),
                "assigning variable y1sigma_eta_q");
              current_statement__ = 87;
              assign(y2sigma_eta_q, nil_index_list(),
                stan::math::exp(stan::model::deep_copy(y2sigma_eta_q)),
                "assigning variable y2sigma_eta_q");
            } 
            current_statement__ = 90;
            assign(e_eta_q, nil_index_list(),
              add(stan::model::deep_copy(e_eta_q),
                add(
                  add(
                    add(multiply(a_beta[(1 - 1)], y1mu_eta_q),
                      multiply(a_beta[(2 - 1)], y1sigma_eta_q)),
                    multiply(a_beta[(3 - 1)], y2mu_eta_q)),
                  multiply(a_beta[(4 - 1)], y2sigma_eta_q))),
              "assigning variable e_eta_q");
          }
          current_statement__ = 94;
          assign(log_basehaz, nil_index_list(),
            add(norm_const, multiply(basehaz_X, e_aux)),
            "assigning variable log_basehaz");
          current_statement__ = 95;
          assign(log_haz_q, nil_index_list(), add(log_basehaz, e_eta_q),
            "assigning variable log_haz_q");
          current_statement__ = 96;
          assign(log_haz_etimes, nil_index_list(), head(log_haz_q, Nevents),
            "assigning variable log_haz_etimes");
          current_statement__ = 97;
          assign(log_haz_qtimes, nil_index_list(),
            tail(log_haz_q, Npat_times_qnodes),
            "assigning variable log_haz_qtimes");
          current_statement__ = 98;
          lp_accum__.add(
            (sum(log_haz_etimes) -
              dot_product(qwts, stan::math::exp(log_haz_qtimes))));
        }
        current_statement__ = 100;
        lp_accum__.add(
          normal_lpdf<false>(y1mu_gamma,
            ymu_prior_mean_for_intercept[(1 - 1)],
            ymu_prior_scale_for_intercept[(1 - 1)]));
        current_statement__ = 101;
        lp_accum__.add(
          normal_lpdf<false>(y2mu_gamma,
            ymu_prior_mean_for_intercept[(2 - 1)],
            ymu_prior_scale_for_intercept[(2 - 1)]));
        current_statement__ = 102;
        lp_accum__.add(
          normal_lpdf<false>(y1sigma_gamma,
            ysigma_prior_mean_for_intercept[(1 - 1)],
            ysigma_prior_scale_for_intercept[(1 - 1)]));
        current_statement__ = 103;
        lp_accum__.add(
          normal_lpdf<false>(y2sigma_gamma,
            ysigma_prior_mean_for_intercept[(2 - 1)],
            ysigma_prior_scale_for_intercept[(2 - 1)]));
        current_statement__ = 104;
        lp_accum__.add(normal_lpdf<false>(y1mu_z_beta, 0, 1));
        current_statement__ = 105;
        lp_accum__.add(normal_lpdf<false>(y1sigma_z_beta, 0, 1));
        current_statement__ = 106;
        lp_accum__.add(normal_lpdf<false>(y2mu_z_beta, 0, 1));
        current_statement__ = 107;
        lp_accum__.add(normal_lpdf<false>(y2sigma_z_beta, 0, 1));
        current_statement__ = 108;
        lp_accum__.add(normal_lpdf<false>(e_z_beta, 0, 1));
        current_statement__ = 109;
        lp_accum__.add(normal_lpdf<false>(a_z_beta, 0, 1));
        current_statement__ = 110;
        lp_accum__.add(normal_lpdf<false>(e_aux_unscaled, 0, 1));
        current_statement__ = 111;
        lp_accum__.add(
          student_t_lpdf<false>(b_sd, b_prior_df, 0, b_prior_scale));
        current_statement__ = 112;
        lp_accum__.add(normal_lpdf<false>(to_vector(z_b_mat), 0, 1));
        current_statement__ = 114;
        if (logical_gt(b_K, 1)) {
          current_statement__ = 113;
          lp_accum__.add(
            lkj_corr_cholesky_lpdf<false>(b_cholesky, b_prior_regularization));
        } 
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr>
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.resize(0);
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    static const char* function__ = "model_jmwiv_namespace::write_array";
(void) function__;  // suppress unused var warning
    (void) function__;  // suppress unused var warning
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    
    try {
      double y1mu_gamma;
      y1mu_gamma = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 1;
      y1mu_gamma = in__.scalar();
      double y1sigma_gamma;
      y1sigma_gamma = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 2;
      y1sigma_gamma = in__.scalar();
      double y2mu_gamma;
      y2mu_gamma = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 3;
      y2mu_gamma = in__.scalar();
      double y2sigma_gamma;
      y2sigma_gamma = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 4;
      y2sigma_gamma = in__.scalar();
      Eigen::Matrix<double, -1, 1> y1mu_z_beta;
      y1mu_z_beta = Eigen::Matrix<double, -1, 1>(y1mu_z_beta_1dim__);
      stan::math::fill(y1mu_z_beta, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 5;
      y1mu_z_beta = in__.vector(y1mu_z_beta_1dim__);
      Eigen::Matrix<double, -1, 1> y1sigma_z_beta;
      y1sigma_z_beta = Eigen::Matrix<double, -1, 1>(y1sigma_z_beta_1dim__);
      stan::math::fill(y1sigma_z_beta, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 6;
      y1sigma_z_beta = in__.vector(y1sigma_z_beta_1dim__);
      Eigen::Matrix<double, -1, 1> y2mu_z_beta;
      y2mu_z_beta = Eigen::Matrix<double, -1, 1>(y2mu_z_beta_1dim__);
      stan::math::fill(y2mu_z_beta, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 7;
      y2mu_z_beta = in__.vector(y2mu_z_beta_1dim__);
      Eigen::Matrix<double, -1, 1> y2sigma_z_beta;
      y2sigma_z_beta = Eigen::Matrix<double, -1, 1>(y2sigma_z_beta_1dim__);
      stan::math::fill(y2sigma_z_beta, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 8;
      y2sigma_z_beta = in__.vector(y2sigma_z_beta_1dim__);
      Eigen::Matrix<double, -1, 1> b_sd;
      b_sd = Eigen::Matrix<double, -1, 1>(b_K);
      stan::math::fill(b_sd, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 9;
      b_sd = in__.vector(b_K);
      current_statement__ = 9;
      for (int sym1__ = 1; sym1__ <= b_K; ++sym1__) {
        current_statement__ = 9;
        assign(b_sd, cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lb_constrain(b_sd[(sym1__ - 1)], 0),
          "assigning variable b_sd");}
      Eigen::Matrix<double, -1, -1> z_b_mat;
      z_b_mat = Eigen::Matrix<double, -1, -1>(b_K, b_N);
      stan::math::fill(z_b_mat, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 10;
      z_b_mat = in__.matrix(b_K, b_N);
      Eigen::Matrix<double, -1, -1> b_cholesky;
      b_cholesky = Eigen::Matrix<double, -1, -1>(b_cholesky_1dim__, b_cholesky_2dim__);
      stan::math::fill(b_cholesky, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<local_scalar_t__, -1, 1> b_cholesky_in__;
      b_cholesky_in__ = Eigen::Matrix<local_scalar_t__, -1, 1>(((b_cholesky_1dim__
                                                                  *
                                                                  (b_cholesky_1dim__
                                                                    - 1)) /
                                                                 2));
      stan::math::fill(b_cholesky_in__, DUMMY_VAR__);
      
      current_statement__ = 11;
      b_cholesky_in__ = in__.vector(
                          ((b_cholesky_1dim__ * (b_cholesky_1dim__ - 1)) / 2));
      current_statement__ = 11;
      assign(b_cholesky, nil_index_list(),
        stan::math::cholesky_corr_constrain(b_cholesky_in__,
          b_cholesky_1dim__), "assigning variable b_cholesky");
      Eigen::Matrix<double, -1, 1> e_z_beta;
      e_z_beta = Eigen::Matrix<double, -1, 1>(e_K);
      stan::math::fill(e_z_beta, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 12;
      e_z_beta = in__.vector(e_K);
      Eigen::Matrix<double, -1, 1> a_z_beta;
      a_z_beta = Eigen::Matrix<double, -1, 1>(a_K);
      stan::math::fill(a_z_beta, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 13;
      a_z_beta = in__.vector(a_K);
      Eigen::Matrix<double, -1, 1> e_aux_unscaled;
      e_aux_unscaled = Eigen::Matrix<double, -1, 1>(basehaz_df);
      stan::math::fill(e_aux_unscaled, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 14;
      e_aux_unscaled = in__.vector(basehaz_df);
      Eigen::Matrix<double, -1, 1> y1mu_beta;
      y1mu_beta = Eigen::Matrix<double, -1, 1>(y1mu_beta_1dim__);
      stan::math::fill(y1mu_beta, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, 1> y1sigma_beta;
      y1sigma_beta = Eigen::Matrix<double, -1, 1>(y1sigma_beta_1dim__);
      stan::math::fill(y1sigma_beta, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, 1> y2mu_beta;
      y2mu_beta = Eigen::Matrix<double, -1, 1>(y2mu_beta_1dim__);
      stan::math::fill(y2mu_beta, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, 1> y2sigma_beta;
      y2sigma_beta = Eigen::Matrix<double, -1, 1>(y2sigma_beta_1dim__);
      stan::math::fill(y2sigma_beta, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, 1> e_beta;
      e_beta = Eigen::Matrix<double, -1, 1>(e_K);
      stan::math::fill(e_beta, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, 1> a_beta;
      a_beta = Eigen::Matrix<double, -1, 1>(a_K);
      stan::math::fill(a_beta, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, 1> e_aux;
      e_aux = Eigen::Matrix<double, -1, 1>(basehaz_df);
      stan::math::fill(e_aux, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, -1> b_mat;
      b_mat = Eigen::Matrix<double, -1, -1>(b_N, b_K);
      stan::math::fill(b_mat, std::numeric_limits<double>::quiet_NaN());
      
      vars__.emplace_back(y1mu_gamma);
      vars__.emplace_back(y1sigma_gamma);
      vars__.emplace_back(y2mu_gamma);
      vars__.emplace_back(y2sigma_gamma);
      for (int sym1__ = 1; sym1__ <= y1mu_z_beta_1dim__; ++sym1__) {
        vars__.emplace_back(y1mu_z_beta[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= y1sigma_z_beta_1dim__; ++sym1__) {
        vars__.emplace_back(y1sigma_z_beta[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= y2mu_z_beta_1dim__; ++sym1__) {
        vars__.emplace_back(y2mu_z_beta[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= y2sigma_z_beta_1dim__; ++sym1__) {
        vars__.emplace_back(y2sigma_z_beta[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= b_K; ++sym1__) {
        vars__.emplace_back(b_sd[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= b_N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= b_K; ++sym2__) {
          vars__.emplace_back(
            rvalue(z_b_mat,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())), "z_b_mat"));
        }}
      for (int sym1__ = 1; sym1__ <= b_cholesky_2dim__; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= b_cholesky_1dim__; ++sym2__) {
          vars__.emplace_back(
            rvalue(b_cholesky,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              "b_cholesky"));}}
      for (int sym1__ = 1; sym1__ <= e_K; ++sym1__) {
        vars__.emplace_back(e_z_beta[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= a_K; ++sym1__) {
        vars__.emplace_back(a_z_beta[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= basehaz_df; ++sym1__) {
        vars__.emplace_back(e_aux_unscaled[(sym1__ - 1)]);}
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      current_statement__ = 23;
      assign(y1mu_beta, nil_index_list(),
        add(elt_multiply(y1mu_z_beta, y1mu_prior_scale), y1mu_prior_mean),
        "assigning variable y1mu_beta");
      current_statement__ = 24;
      assign(y2mu_beta, nil_index_list(),
        add(elt_multiply(y2mu_z_beta, y2mu_prior_scale), y2mu_prior_mean),
        "assigning variable y2mu_beta");
      current_statement__ = 25;
      assign(y1sigma_beta, nil_index_list(),
        add(elt_multiply(y1sigma_z_beta, y1sigma_prior_scale),
          y1sigma_prior_mean), "assigning variable y1sigma_beta");
      current_statement__ = 26;
      assign(y2sigma_beta, nil_index_list(),
        add(elt_multiply(y2sigma_z_beta, y2sigma_prior_scale),
          y2sigma_prior_mean), "assigning variable y2sigma_beta");
      current_statement__ = 27;
      assign(e_beta, nil_index_list(),
        add(elt_multiply(e_z_beta, e_prior_scale), e_prior_mean),
        "assigning variable e_beta");
      current_statement__ = 28;
      assign(a_beta, nil_index_list(),
        add(elt_multiply(a_z_beta, a_prior_scale), a_prior_mean),
        "assigning variable a_beta");
      current_statement__ = 29;
      assign(e_aux, nil_index_list(),
        add(elt_multiply(e_aux_unscaled, e_prior_scale_for_aux),
          e_prior_mean_for_aux), "assigning variable e_aux");
      current_statement__ = 33;
      if (logical_eq(b_K, 1)) {
        current_statement__ = 32;
        assign(b_mat, nil_index_list(),
          transpose(multiply(b_sd[(1 - 1)], z_b_mat)),
          "assigning variable b_mat");
      } else {
        current_statement__ = 31;
        if (logical_gt(b_K, 1)) {
          current_statement__ = 30;
          assign(b_mat, nil_index_list(),
            transpose(multiply(diag_pre_multiply(b_sd, b_cholesky), z_b_mat)),
            "assigning variable b_mat");
        } 
      }
      if (emit_transformed_parameters__) {
        for (int sym1__ = 1; sym1__ <= y1mu_beta_1dim__; ++sym1__) {
          vars__.emplace_back(y1mu_beta[(sym1__ - 1)]);}
        for (int sym1__ = 1; sym1__ <= y1sigma_beta_1dim__; ++sym1__) {
          vars__.emplace_back(y1sigma_beta[(sym1__ - 1)]);}
        for (int sym1__ = 1; sym1__ <= y2mu_beta_1dim__; ++sym1__) {
          vars__.emplace_back(y2mu_beta[(sym1__ - 1)]);}
        for (int sym1__ = 1; sym1__ <= y2sigma_beta_1dim__; ++sym1__) {
          vars__.emplace_back(y2sigma_beta[(sym1__ - 1)]);}
        for (int sym1__ = 1; sym1__ <= e_K; ++sym1__) {
          vars__.emplace_back(e_beta[(sym1__ - 1)]);}
        for (int sym1__ = 1; sym1__ <= a_K; ++sym1__) {
          vars__.emplace_back(a_beta[(sym1__ - 1)]);}
        for (int sym1__ = 1; sym1__ <= basehaz_df; ++sym1__) {
          vars__.emplace_back(e_aux[(sym1__ - 1)]);}
        for (int sym1__ = 1; sym1__ <= b_K; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= b_N; ++sym2__) {
            vars__.emplace_back(
              rvalue(b_mat,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(sym1__), nil_index_list())), "b_mat"));
          }}
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
      double y1mu_Intercept;
      y1mu_Intercept = std::numeric_limits<double>::quiet_NaN();
      
      double y2mu_Intercept;
      y2mu_Intercept = std::numeric_limits<double>::quiet_NaN();
      
      double y1sigma_Intercept;
      y1sigma_Intercept = std::numeric_limits<double>::quiet_NaN();
      
      double y2sigma_Intercept;
      y2sigma_Intercept = std::numeric_limits<double>::quiet_NaN();
      
      double e_Intercept;
      e_Intercept = std::numeric_limits<double>::quiet_NaN();
      
      Eigen::Matrix<double, -1, 1> b_cov;
      b_cov = Eigen::Matrix<double, -1, 1>(b_cov_1dim__);
      stan::math::fill(b_cov, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 40;
      y1mu_Intercept = (y1mu_gamma - dot_product(y1mu_Xbar, y1mu_beta));
      current_statement__ = 41;
      y2mu_Intercept = (y2mu_gamma - dot_product(y2mu_Xbar, y2mu_beta));
      current_statement__ = 42;
      y1sigma_Intercept = (y1sigma_gamma -
                            dot_product(y1sigma_Xbar, y1sigma_beta));
      current_statement__ = 43;
      y2sigma_Intercept = (y2sigma_gamma -
                            dot_product(y2sigma_Xbar, y2sigma_beta));
      current_statement__ = 44;
      e_Intercept = (0.0 - dot_product(e_Xbar, e_beta));
      current_statement__ = 47;
      if (logical_eq(b_K, 1)) {
        current_statement__ = 46;
        assign(b_cov, cons_list(index_uni(1), nil_index_list()),
          (b_sd[(1 - 1)] * b_sd[(1 - 1)]), "assigning variable b_cov");
      } else {
        current_statement__ = 45;
        assign(b_cov, nil_index_list(),
          rvalue(
            to_vector(
  quad_form_diag(multiply_lower_tri_self_transpose(b_cholesky), b_sd)),
            cons_list(index_multi(b_cov_idx), nil_index_list()),
            "to_vector(quad_form_diag(multiply_lower_tri_self_transpose(b_cholesky), b_sd))"),
          "assigning variable b_cov");
      }
      vars__.emplace_back(y1mu_Intercept);
      vars__.emplace_back(y2mu_Intercept);
      vars__.emplace_back(y1sigma_Intercept);
      vars__.emplace_back(y2sigma_Intercept);
      vars__.emplace_back(e_Intercept);
      for (int sym1__ = 1; sym1__ <= b_cov_1dim__; ++sym1__) {
        vars__.emplace_back(b_cov[(sym1__ - 1)]);}
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, stan::require_std_vector_t<VecVar>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void transform_inits_impl(const stan::io::var_context& context__,
                                   VecI& params_i__, VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.clear();
    vars__.reserve(num_params_r__);
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      double y1mu_gamma;
      y1mu_gamma = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 1;
      y1mu_gamma = context__.vals_r("y1mu_gamma")[(1 - 1)];
      double y1sigma_gamma;
      y1sigma_gamma = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 2;
      y1sigma_gamma = context__.vals_r("y1sigma_gamma")[(1 - 1)];
      double y2mu_gamma;
      y2mu_gamma = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 3;
      y2mu_gamma = context__.vals_r("y2mu_gamma")[(1 - 1)];
      double y2sigma_gamma;
      y2sigma_gamma = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 4;
      y2sigma_gamma = context__.vals_r("y2sigma_gamma")[(1 - 1)];
      Eigen::Matrix<double, -1, 1> y1mu_z_beta;
      y1mu_z_beta = Eigen::Matrix<double, -1, 1>(y1mu_z_beta_1dim__);
      stan::math::fill(y1mu_z_beta, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> y1mu_z_beta_flat__;
        current_statement__ = 5;
        assign(y1mu_z_beta_flat__, nil_index_list(),
          context__.vals_r("y1mu_z_beta"),
          "assigning variable y1mu_z_beta_flat__");
        current_statement__ = 5;
        pos__ = 1;
        current_statement__ = 5;
        for (int sym1__ = 1; sym1__ <= y1mu_z_beta_1dim__; ++sym1__) {
          current_statement__ = 5;
          assign(y1mu_z_beta, cons_list(index_uni(sym1__), nil_index_list()),
            y1mu_z_beta_flat__[(pos__ - 1)], "assigning variable y1mu_z_beta");
          current_statement__ = 5;
          pos__ = (pos__ + 1);}
      }
      Eigen::Matrix<double, -1, 1> y1sigma_z_beta;
      y1sigma_z_beta = Eigen::Matrix<double, -1, 1>(y1sigma_z_beta_1dim__);
      stan::math::fill(y1sigma_z_beta, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> y1sigma_z_beta_flat__;
        current_statement__ = 6;
        assign(y1sigma_z_beta_flat__, nil_index_list(),
          context__.vals_r("y1sigma_z_beta"),
          "assigning variable y1sigma_z_beta_flat__");
        current_statement__ = 6;
        pos__ = 1;
        current_statement__ = 6;
        for (int sym1__ = 1; sym1__ <= y1sigma_z_beta_1dim__; ++sym1__) {
          current_statement__ = 6;
          assign(y1sigma_z_beta,
            cons_list(index_uni(sym1__), nil_index_list()),
            y1sigma_z_beta_flat__[(pos__ - 1)],
            "assigning variable y1sigma_z_beta");
          current_statement__ = 6;
          pos__ = (pos__ + 1);}
      }
      Eigen::Matrix<double, -1, 1> y2mu_z_beta;
      y2mu_z_beta = Eigen::Matrix<double, -1, 1>(y2mu_z_beta_1dim__);
      stan::math::fill(y2mu_z_beta, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> y2mu_z_beta_flat__;
        current_statement__ = 7;
        assign(y2mu_z_beta_flat__, nil_index_list(),
          context__.vals_r("y2mu_z_beta"),
          "assigning variable y2mu_z_beta_flat__");
        current_statement__ = 7;
        pos__ = 1;
        current_statement__ = 7;
        for (int sym1__ = 1; sym1__ <= y2mu_z_beta_1dim__; ++sym1__) {
          current_statement__ = 7;
          assign(y2mu_z_beta, cons_list(index_uni(sym1__), nil_index_list()),
            y2mu_z_beta_flat__[(pos__ - 1)], "assigning variable y2mu_z_beta");
          current_statement__ = 7;
          pos__ = (pos__ + 1);}
      }
      Eigen::Matrix<double, -1, 1> y2sigma_z_beta;
      y2sigma_z_beta = Eigen::Matrix<double, -1, 1>(y2sigma_z_beta_1dim__);
      stan::math::fill(y2sigma_z_beta, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> y2sigma_z_beta_flat__;
        current_statement__ = 8;
        assign(y2sigma_z_beta_flat__, nil_index_list(),
          context__.vals_r("y2sigma_z_beta"),
          "assigning variable y2sigma_z_beta_flat__");
        current_statement__ = 8;
        pos__ = 1;
        current_statement__ = 8;
        for (int sym1__ = 1; sym1__ <= y2sigma_z_beta_1dim__; ++sym1__) {
          current_statement__ = 8;
          assign(y2sigma_z_beta,
            cons_list(index_uni(sym1__), nil_index_list()),
            y2sigma_z_beta_flat__[(pos__ - 1)],
            "assigning variable y2sigma_z_beta");
          current_statement__ = 8;
          pos__ = (pos__ + 1);}
      }
      Eigen::Matrix<double, -1, 1> b_sd;
      b_sd = Eigen::Matrix<double, -1, 1>(b_K);
      stan::math::fill(b_sd, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> b_sd_flat__;
        current_statement__ = 9;
        assign(b_sd_flat__, nil_index_list(), context__.vals_r("b_sd"),
          "assigning variable b_sd_flat__");
        current_statement__ = 9;
        pos__ = 1;
        current_statement__ = 9;
        for (int sym1__ = 1; sym1__ <= b_K; ++sym1__) {
          current_statement__ = 9;
          assign(b_sd, cons_list(index_uni(sym1__), nil_index_list()),
            b_sd_flat__[(pos__ - 1)], "assigning variable b_sd");
          current_statement__ = 9;
          pos__ = (pos__ + 1);}
      }
      Eigen::Matrix<double, -1, 1> b_sd_free__;
      b_sd_free__ = Eigen::Matrix<double, -1, 1>(b_K);
      stan::math::fill(b_sd_free__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 9;
      for (int sym1__ = 1; sym1__ <= b_K; ++sym1__) {
        current_statement__ = 9;
        assign(b_sd_free__, cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lb_free(b_sd[(sym1__ - 1)], 0),
          "assigning variable b_sd_free__");}
      Eigen::Matrix<double, -1, -1> z_b_mat;
      z_b_mat = Eigen::Matrix<double, -1, -1>(b_K, b_N);
      stan::math::fill(z_b_mat, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> z_b_mat_flat__;
        current_statement__ = 10;
        assign(z_b_mat_flat__, nil_index_list(), context__.vals_r("z_b_mat"),
          "assigning variable z_b_mat_flat__");
        current_statement__ = 10;
        pos__ = 1;
        current_statement__ = 10;
        for (int sym1__ = 1; sym1__ <= b_N; ++sym1__) {
          current_statement__ = 10;
          for (int sym2__ = 1; sym2__ <= b_K; ++sym2__) {
            current_statement__ = 10;
            assign(z_b_mat,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              z_b_mat_flat__[(pos__ - 1)], "assigning variable z_b_mat");
            current_statement__ = 10;
            pos__ = (pos__ + 1);}}
      }
      Eigen::Matrix<double, -1, -1> b_cholesky;
      b_cholesky = Eigen::Matrix<double, -1, -1>(b_cholesky_1dim__, b_cholesky_2dim__);
      stan::math::fill(b_cholesky, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> b_cholesky_flat__;
        current_statement__ = 11;
        assign(b_cholesky_flat__, nil_index_list(),
          context__.vals_r("b_cholesky"),
          "assigning variable b_cholesky_flat__");
        current_statement__ = 11;
        pos__ = 1;
        current_statement__ = 11;
        for (int sym1__ = 1; sym1__ <= b_cholesky_2dim__; ++sym1__) {
          current_statement__ = 11;
          for (int sym2__ = 1; sym2__ <= b_cholesky_1dim__; ++sym2__) {
            current_statement__ = 11;
            assign(b_cholesky,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              b_cholesky_flat__[(pos__ - 1)], "assigning variable b_cholesky");
            current_statement__ = 11;
            pos__ = (pos__ + 1);}}
      }
      Eigen::Matrix<double, -1, 1> b_cholesky_free__;
      b_cholesky_free__ = Eigen::Matrix<double, -1, 1>(((b_cholesky_1dim__ *
                                                          (b_cholesky_1dim__
                                                            - 1)) / 2));
      stan::math::fill(b_cholesky_free__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 11;
      assign(b_cholesky_free__, nil_index_list(),
        stan::math::cholesky_corr_free(b_cholesky),
        "assigning variable b_cholesky_free__");
      Eigen::Matrix<double, -1, 1> e_z_beta;
      e_z_beta = Eigen::Matrix<double, -1, 1>(e_K);
      stan::math::fill(e_z_beta, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> e_z_beta_flat__;
        current_statement__ = 12;
        assign(e_z_beta_flat__, nil_index_list(),
          context__.vals_r("e_z_beta"), "assigning variable e_z_beta_flat__");
        current_statement__ = 12;
        pos__ = 1;
        current_statement__ = 12;
        for (int sym1__ = 1; sym1__ <= e_K; ++sym1__) {
          current_statement__ = 12;
          assign(e_z_beta, cons_list(index_uni(sym1__), nil_index_list()),
            e_z_beta_flat__[(pos__ - 1)], "assigning variable e_z_beta");
          current_statement__ = 12;
          pos__ = (pos__ + 1);}
      }
      Eigen::Matrix<double, -1, 1> a_z_beta;
      a_z_beta = Eigen::Matrix<double, -1, 1>(a_K);
      stan::math::fill(a_z_beta, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> a_z_beta_flat__;
        current_statement__ = 13;
        assign(a_z_beta_flat__, nil_index_list(),
          context__.vals_r("a_z_beta"), "assigning variable a_z_beta_flat__");
        current_statement__ = 13;
        pos__ = 1;
        current_statement__ = 13;
        for (int sym1__ = 1; sym1__ <= a_K; ++sym1__) {
          current_statement__ = 13;
          assign(a_z_beta, cons_list(index_uni(sym1__), nil_index_list()),
            a_z_beta_flat__[(pos__ - 1)], "assigning variable a_z_beta");
          current_statement__ = 13;
          pos__ = (pos__ + 1);}
      }
      Eigen::Matrix<double, -1, 1> e_aux_unscaled;
      e_aux_unscaled = Eigen::Matrix<double, -1, 1>(basehaz_df);
      stan::math::fill(e_aux_unscaled, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> e_aux_unscaled_flat__;
        current_statement__ = 14;
        assign(e_aux_unscaled_flat__, nil_index_list(),
          context__.vals_r("e_aux_unscaled"),
          "assigning variable e_aux_unscaled_flat__");
        current_statement__ = 14;
        pos__ = 1;
        current_statement__ = 14;
        for (int sym1__ = 1; sym1__ <= basehaz_df; ++sym1__) {
          current_statement__ = 14;
          assign(e_aux_unscaled,
            cons_list(index_uni(sym1__), nil_index_list()),
            e_aux_unscaled_flat__[(pos__ - 1)],
            "assigning variable e_aux_unscaled");
          current_statement__ = 14;
          pos__ = (pos__ + 1);}
      }
      vars__.emplace_back(y1mu_gamma);
      vars__.emplace_back(y1sigma_gamma);
      vars__.emplace_back(y2mu_gamma);
      vars__.emplace_back(y2sigma_gamma);
      for (int sym1__ = 1; sym1__ <= y1mu_z_beta_1dim__; ++sym1__) {
        vars__.emplace_back(y1mu_z_beta[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= y1sigma_z_beta_1dim__; ++sym1__) {
        vars__.emplace_back(y1sigma_z_beta[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= y2mu_z_beta_1dim__; ++sym1__) {
        vars__.emplace_back(y2mu_z_beta[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= y2sigma_z_beta_1dim__; ++sym1__) {
        vars__.emplace_back(y2sigma_z_beta[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= b_K; ++sym1__) {
        vars__.emplace_back(b_sd_free__[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= b_N; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= b_K; ++sym2__) {
          vars__.emplace_back(
            rvalue(z_b_mat,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())), "z_b_mat"));
        }}
      for (int sym1__ = 1;
           sym1__ <= ((b_cholesky_1dim__ * (b_cholesky_1dim__ - 1)) / 2);
           ++sym1__) { vars__.emplace_back(b_cholesky_free__[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= e_K; ++sym1__) {
        vars__.emplace_back(e_z_beta[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= a_K; ++sym1__) {
        vars__.emplace_back(a_z_beta[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= basehaz_df; ++sym1__) {
        vars__.emplace_back(e_aux_unscaled[(sym1__ - 1)]);}
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__.clear();
    names__.emplace_back("y1mu_gamma");
    names__.emplace_back("y1sigma_gamma");
    names__.emplace_back("y2mu_gamma");
    names__.emplace_back("y2sigma_gamma");
    names__.emplace_back("y1mu_z_beta");
    names__.emplace_back("y1sigma_z_beta");
    names__.emplace_back("y2mu_z_beta");
    names__.emplace_back("y2sigma_z_beta");
    names__.emplace_back("b_sd");
    names__.emplace_back("z_b_mat");
    names__.emplace_back("b_cholesky");
    names__.emplace_back("e_z_beta");
    names__.emplace_back("a_z_beta");
    names__.emplace_back("e_aux_unscaled");
    names__.emplace_back("y1mu_beta");
    names__.emplace_back("y1sigma_beta");
    names__.emplace_back("y2mu_beta");
    names__.emplace_back("y2sigma_beta");
    names__.emplace_back("e_beta");
    names__.emplace_back("a_beta");
    names__.emplace_back("e_aux");
    names__.emplace_back("b_mat");
    names__.emplace_back("y1mu_Intercept");
    names__.emplace_back("y2mu_Intercept");
    names__.emplace_back("y1sigma_Intercept");
    names__.emplace_back("y2sigma_Intercept");
    names__.emplace_back("e_Intercept");
    names__.emplace_back("b_cov");
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    dimss__.clear();
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(y1mu_z_beta_1dim__)
                                             });
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(y1sigma_z_beta_1dim__)
                                             });
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(y2mu_z_beta_1dim__)
                                             });
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(y2sigma_z_beta_1dim__)
                                             });
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(b_K)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(b_K),
                                             static_cast<size_t>(b_N)});
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(b_cholesky_1dim__)
                                             ,
                                             static_cast<size_t>(b_cholesky_2dim__)
                                             });
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(e_K)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(a_K)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(basehaz_df)});
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(y1mu_beta_1dim__)
                                             });
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(y1sigma_beta_1dim__)
                                             });
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(y2mu_beta_1dim__)
                                             });
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(y2sigma_beta_1dim__)
                                             });
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(e_K)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(a_K)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(basehaz_df)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(b_N),
                                             static_cast<size_t>(b_K)});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(b_cov_1dim__)});
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "y1mu_gamma");
    param_names__.emplace_back(std::string() + "y1sigma_gamma");
    param_names__.emplace_back(std::string() + "y2mu_gamma");
    param_names__.emplace_back(std::string() + "y2sigma_gamma");
    for (int sym1__ = 1; sym1__ <= y1mu_z_beta_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "y1mu_z_beta" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= y1sigma_z_beta_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "y1sigma_z_beta" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= y2mu_z_beta_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "y2mu_z_beta" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= y2sigma_z_beta_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "y2sigma_z_beta" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= b_K; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "b_sd" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= b_N; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= b_K; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "z_b_mat" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }}
      }}
    for (int sym1__ = 1; sym1__ <= b_cholesky_2dim__; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= b_cholesky_1dim__; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "b_cholesky" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }}
      }}
    for (int sym1__ = 1; sym1__ <= e_K; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "e_z_beta" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= a_K; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "a_z_beta" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= basehaz_df; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "e_aux_unscaled" + '.' + std::to_string(sym1__));
      }}
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= y1mu_beta_1dim__; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "y1mu_beta" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= y1sigma_beta_1dim__; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "y1sigma_beta" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= y2mu_beta_1dim__; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "y2mu_beta" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= y2sigma_beta_1dim__; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "y2sigma_beta" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= e_K; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "e_beta" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= a_K; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "a_beta" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= basehaz_df; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "e_aux" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= b_K; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= b_N; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "b_mat" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
    }
    
    if (emit_generated_quantities__) {
      param_names__.emplace_back(std::string() + "y1mu_Intercept");
      param_names__.emplace_back(std::string() + "y2mu_Intercept");
      param_names__.emplace_back(std::string() + "y1sigma_Intercept");
      param_names__.emplace_back(std::string() + "y2sigma_Intercept");
      param_names__.emplace_back(std::string() + "e_Intercept");
      for (int sym1__ = 1; sym1__ <= b_cov_1dim__; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "b_cov" + '.' + std::to_string(sym1__));
        }}
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "y1mu_gamma");
    param_names__.emplace_back(std::string() + "y1sigma_gamma");
    param_names__.emplace_back(std::string() + "y2mu_gamma");
    param_names__.emplace_back(std::string() + "y2sigma_gamma");
    for (int sym1__ = 1; sym1__ <= y1mu_z_beta_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "y1mu_z_beta" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= y1sigma_z_beta_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "y1sigma_z_beta" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= y2mu_z_beta_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "y2mu_z_beta" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= y2sigma_z_beta_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "y2sigma_z_beta" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= b_K; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "b_sd" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= b_N; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= b_K; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "z_b_mat" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }}
      }}
    for (int sym1__ = 1;
         sym1__ <= ((b_cholesky_1dim__ * (b_cholesky_1dim__ - 1)) / 2);
         ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "b_cholesky" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= e_K; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "e_z_beta" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= a_K; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "a_z_beta" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= basehaz_df; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "e_aux_unscaled" + '.' + std::to_string(sym1__));
      }}
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= y1mu_beta_1dim__; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "y1mu_beta" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= y1sigma_beta_1dim__; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "y1sigma_beta" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= y2mu_beta_1dim__; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "y2mu_beta" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= y2sigma_beta_1dim__; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "y2sigma_beta" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= e_K; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "e_beta" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= a_K; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "a_beta" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= basehaz_df; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "e_aux" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= b_K; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= b_N; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "b_mat" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
    }
    
    if (emit_generated_quantities__) {
      param_names__.emplace_back(std::string() + "y1mu_Intercept");
      param_names__.emplace_back(std::string() + "y2mu_Intercept");
      param_names__.emplace_back(std::string() + "y1sigma_Intercept");
      param_names__.emplace_back(std::string() + "y2sigma_Intercept");
      param_names__.emplace_back(std::string() + "e_Intercept");
      for (int sym1__ = 1; sym1__ <= b_cov_1dim__; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "b_cov" + '.' + std::to_string(sym1__));
        }}
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"y1mu_gamma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"y1sigma_gamma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"y2mu_gamma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"y2sigma_gamma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"y1mu_z_beta\",\"type\":{\"name\":\"vector\",\"length\":" << y1mu_z_beta_1dim__ << "},\"block\":\"parameters\"},{\"name\":\"y1sigma_z_beta\",\"type\":{\"name\":\"vector\",\"length\":" << y1sigma_z_beta_1dim__ << "},\"block\":\"parameters\"},{\"name\":\"y2mu_z_beta\",\"type\":{\"name\":\"vector\",\"length\":" << y2mu_z_beta_1dim__ << "},\"block\":\"parameters\"},{\"name\":\"y2sigma_z_beta\",\"type\":{\"name\":\"vector\",\"length\":" << y2sigma_z_beta_1dim__ << "},\"block\":\"parameters\"},{\"name\":\"b_sd\",\"type\":{\"name\":\"vector\",\"length\":" << b_K << "},\"block\":\"parameters\"},{\"name\":\"z_b_mat\",\"type\":{\"name\":\"matrix\",\"rows\":" << b_K << ",\"cols\":" << b_N << "},\"block\":\"parameters\"},{\"name\":\"b_cholesky\",\"type\":{\"name\":\"matrix\",\"rows\":" << b_cholesky_1dim__ << ",\"cols\":" << b_cholesky_2dim__ << "},\"block\":\"parameters\"},{\"name\":\"e_z_beta\",\"type\":{\"name\":\"vector\",\"length\":" << e_K << "},\"block\":\"parameters\"},{\"name\":\"a_z_beta\",\"type\":{\"name\":\"vector\",\"length\":" << a_K << "},\"block\":\"parameters\"},{\"name\":\"e_aux_unscaled\",\"type\":{\"name\":\"vector\",\"length\":" << basehaz_df << "},\"block\":\"parameters\"},{\"name\":\"y1mu_beta\",\"type\":{\"name\":\"vector\",\"length\":" << y1mu_beta_1dim__ << "},\"block\":\"transformed_parameters\"},{\"name\":\"y1sigma_beta\",\"type\":{\"name\":\"vector\",\"length\":" << y1sigma_beta_1dim__ << "},\"block\":\"transformed_parameters\"},{\"name\":\"y2mu_beta\",\"type\":{\"name\":\"vector\",\"length\":" << y2mu_beta_1dim__ << "},\"block\":\"transformed_parameters\"},{\"name\":\"y2sigma_beta\",\"type\":{\"name\":\"vector\",\"length\":" << y2sigma_beta_1dim__ << "},\"block\":\"transformed_parameters\"},{\"name\":\"e_beta\",\"type\":{\"name\":\"vector\",\"length\":" << e_K << "},\"block\":\"transformed_parameters\"},{\"name\":\"a_beta\",\"type\":{\"name\":\"vector\",\"length\":" << a_K << "},\"block\":\"transformed_parameters\"},{\"name\":\"e_aux\",\"type\":{\"name\":\"vector\",\"length\":" << basehaz_df << "},\"block\":\"transformed_parameters\"},{\"name\":\"b_mat\",\"type\":{\"name\":\"matrix\",\"rows\":" << b_N << ",\"cols\":" << b_K << "},\"block\":\"transformed_parameters\"},{\"name\":\"y1mu_Intercept\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"y2mu_Intercept\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"y1sigma_Intercept\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"y2sigma_Intercept\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"e_Intercept\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"b_cov\",\"type\":{\"name\":\"vector\",\"length\":" << b_cov_1dim__ << "},\"block\":\"generated_quantities\"}]";
    return s__.str();
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"y1mu_gamma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"y1sigma_gamma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"y2mu_gamma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"y2sigma_gamma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"y1mu_z_beta\",\"type\":{\"name\":\"vector\",\"length\":" << y1mu_z_beta_1dim__ << "},\"block\":\"parameters\"},{\"name\":\"y1sigma_z_beta\",\"type\":{\"name\":\"vector\",\"length\":" << y1sigma_z_beta_1dim__ << "},\"block\":\"parameters\"},{\"name\":\"y2mu_z_beta\",\"type\":{\"name\":\"vector\",\"length\":" << y2mu_z_beta_1dim__ << "},\"block\":\"parameters\"},{\"name\":\"y2sigma_z_beta\",\"type\":{\"name\":\"vector\",\"length\":" << y2sigma_z_beta_1dim__ << "},\"block\":\"parameters\"},{\"name\":\"b_sd\",\"type\":{\"name\":\"vector\",\"length\":" << b_K << "},\"block\":\"parameters\"},{\"name\":\"z_b_mat\",\"type\":{\"name\":\"matrix\",\"rows\":" << b_K << ",\"cols\":" << b_N << "},\"block\":\"parameters\"},{\"name\":\"b_cholesky\",\"type\":{\"name\":\"vector\",\"length\":" << ((b_cholesky_1dim__ * (b_cholesky_1dim__ - 1)) / 2) << "},\"block\":\"parameters\"},{\"name\":\"e_z_beta\",\"type\":{\"name\":\"vector\",\"length\":" << e_K << "},\"block\":\"parameters\"},{\"name\":\"a_z_beta\",\"type\":{\"name\":\"vector\",\"length\":" << a_K << "},\"block\":\"parameters\"},{\"name\":\"e_aux_unscaled\",\"type\":{\"name\":\"vector\",\"length\":" << basehaz_df << "},\"block\":\"parameters\"},{\"name\":\"y1mu_beta\",\"type\":{\"name\":\"vector\",\"length\":" << y1mu_beta_1dim__ << "},\"block\":\"transformed_parameters\"},{\"name\":\"y1sigma_beta\",\"type\":{\"name\":\"vector\",\"length\":" << y1sigma_beta_1dim__ << "},\"block\":\"transformed_parameters\"},{\"name\":\"y2mu_beta\",\"type\":{\"name\":\"vector\",\"length\":" << y2mu_beta_1dim__ << "},\"block\":\"transformed_parameters\"},{\"name\":\"y2sigma_beta\",\"type\":{\"name\":\"vector\",\"length\":" << y2sigma_beta_1dim__ << "},\"block\":\"transformed_parameters\"},{\"name\":\"e_beta\",\"type\":{\"name\":\"vector\",\"length\":" << e_K << "},\"block\":\"transformed_parameters\"},{\"name\":\"a_beta\",\"type\":{\"name\":\"vector\",\"length\":" << a_K << "},\"block\":\"transformed_parameters\"},{\"name\":\"e_aux\",\"type\":{\"name\":\"vector\",\"length\":" << basehaz_df << "},\"block\":\"transformed_parameters\"},{\"name\":\"b_mat\",\"type\":{\"name\":\"matrix\",\"rows\":" << b_N << ",\"cols\":" << b_K << "},\"block\":\"transformed_parameters\"},{\"name\":\"y1mu_Intercept\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"y2mu_Intercept\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"y1sigma_Intercept\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"y2sigma_Intercept\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"e_Intercept\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"b_cov\",\"type\":{\"name\":\"vector\",\"length\":" << b_cov_1dim__ << "},\"block\":\"generated_quantities\"}]";
    return s__.str();
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      std::vector<double> vars_vec(vars.size());
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i) {
        vars.coeffRef(i) = vars_vec[i];
      }
    }
    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }
    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }
    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }
  
    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits_impl(context, params_i, params_r_vec, pstream);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i) {
        params_r.coeffRef(i) = params_r_vec[i];
      }
    }
    inline void transform_inits(const stan::io::var_context& context,
                                std::vector<int>& params_i,
                                std::vector<double>& vars,
                                std::ostream* pstream = nullptr) const final {
      transform_inits_impl(context, params_i, vars, pstream);
    }        
};
}
using stan_model = model_jmwiv_namespace::model_jmwiv;
#ifndef USING_R
// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return model_jmwiv_namespace::profiles__;
}
#endif
#endif
